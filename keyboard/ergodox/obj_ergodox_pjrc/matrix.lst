   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB43:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "action_layer.h"
  26:matrix.c      **** #include "print.h"
  27:matrix.c      **** #include "debug.h"
  28:matrix.c      **** #include "util.h"
  29:matrix.c      **** #include "matrix.h"
  30:matrix.c      **** #include "ergodox.h"
  31:matrix.c      **** #include "i2cmaster.h"
  32:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
  33:matrix.c      **** #include  "timer.h"
  34:matrix.c      **** #endif
  35:matrix.c      **** 
  36:matrix.c      **** #ifndef DEBOUNCE
  37:matrix.c      **** #   define DEBOUNCE	5
  38:matrix.c      **** #endif
  39:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  40:matrix.c      **** 
  41:matrix.c      **** /* matrix state(1:on, 0:off) */
  42:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  43:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  44:matrix.c      **** 
  45:matrix.c      **** static matrix_row_t read_cols(uint8_t row);
  46:matrix.c      **** static void init_cols(void);
  47:matrix.c      **** static void unselect_rows();
  48:matrix.c      **** static void select_row(uint8_t row);
  49:matrix.c      **** 
  50:matrix.c      **** static uint8_t mcp23018_reset_loop;
  51:matrix.c      **** 
  52:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
  53:matrix.c      **** uint32_t matrix_timer;
  54:matrix.c      **** uint32_t matrix_scan_count;
  55:matrix.c      **** #endif
  56:matrix.c      **** 
  57:matrix.c      **** inline
  58:matrix.c      **** uint8_t matrix_rows(void)
  59:matrix.c      **** {
  60:matrix.c      ****     return MATRIX_ROWS;
  61:matrix.c      **** }
  62:matrix.c      **** 
  63:matrix.c      **** inline
  64:matrix.c      **** uint8_t matrix_cols(void)
  65:matrix.c      **** {
  66:matrix.c      ****     return MATRIX_COLS;
  67:matrix.c      **** }
  68:matrix.c      **** 
  69:matrix.c      **** void matrix_init(void)
  70:matrix.c      **** {
  71:matrix.c      ****     // initialize row and col
  72:matrix.c      ****     init_ergodox();
  73:matrix.c      ****     mcp23018_status = init_mcp23018();
  74:matrix.c      ****     ergodox_blink_all_leds();
  75:matrix.c      ****     unselect_rows();
  76:matrix.c      ****     init_cols();
  77:matrix.c      **** 
  78:matrix.c      ****     // initialize matrix state: all keys off
  79:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  80:matrix.c      ****         matrix[i] = 0;
  81:matrix.c      ****         matrix_debouncing[i] = 0;
  82:matrix.c      ****     }
  83:matrix.c      **** 
  84:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
  85:matrix.c      ****     matrix_timer = timer_read32();
  86:matrix.c      ****     matrix_scan_count = 0;
  87:matrix.c      **** #endif
  88:matrix.c      **** }
  89:matrix.c      **** 
  90:matrix.c      **** uint8_t matrix_scan(void)
  91:matrix.c      **** {
  92:matrix.c      ****     if (mcp23018_status) { // if there was an error
  93:matrix.c      ****         if (++mcp23018_reset_loop == 0) {
  94:matrix.c      ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
  95:matrix.c      ****             // this will be approx bit more frequent than once per second
  96:matrix.c      ****             print("trying to reset mcp23018\n");
  97:matrix.c      ****             mcp23018_status = init_mcp23018();
  98:matrix.c      ****             if (mcp23018_status) {
  99:matrix.c      ****                 print("left side not responding\n");
 100:matrix.c      ****             } else {
 101:matrix.c      ****                 print("left side attached\n");
 102:matrix.c      ****                 ergodox_blink_all_leds();
 103:matrix.c      ****             }
 104:matrix.c      ****         }
 105:matrix.c      ****     }
 106:matrix.c      **** 
 107:matrix.c      **** #ifdef DEBUG_MATRIX_SCAN_RATE
 108:matrix.c      ****     matrix_scan_count++;
 109:matrix.c      **** 
 110:matrix.c      ****     uint32_t timer_now = timer_read32();
 111:matrix.c      ****     if (TIMER_DIFF_32(timer_now, matrix_timer)>1000) {
 112:matrix.c      ****         print("matrix scan frequency: ");
 113:matrix.c      ****         pdec(matrix_scan_count);
 114:matrix.c      ****         print("\n");
 115:matrix.c      **** 
 116:matrix.c      ****         matrix_timer = timer_now;
 117:matrix.c      ****         matrix_scan_count = 0;
 118:matrix.c      ****     }
 119:matrix.c      **** #endif
 120:matrix.c      **** 
 121:matrix.c      **** #ifdef KEYMAP_CUB
 122:matrix.c      ****     uint8_t layer = biton32(layer_state);
 123:matrix.c      **** 
 124:matrix.c      ****     ergodox_board_led_off();
 125:matrix.c      ****     ergodox_left_led_1_off();
 126:matrix.c      ****     ergodox_left_led_2_off();
 127:matrix.c      ****     ergodox_left_led_3_off();
 128:matrix.c      ****     switch (layer) {
 129:matrix.c      ****         case 1:
 130:matrix.c      ****             // all
 131:matrix.c      ****             ergodox_left_led_1_on();
 132:matrix.c      ****             ergodox_left_led_2_on();
 133:matrix.c      ****             ergodox_left_led_3_on();
 134:matrix.c      ****             break;
 135:matrix.c      ****         case 2:
 136:matrix.c      ****             // blue
 137:matrix.c      ****             ergodox_left_led_2_on();
 138:matrix.c      ****             break;
 139:matrix.c      ****         case 8:
 140:matrix.c      ****             // blue and green
 141:matrix.c      ****             ergodox_left_led_2_on();
 142:matrix.c      ****             // break missed intentionally
 143:matrix.c      ****         case 3:
 144:matrix.c      ****             // green
 145:matrix.c      ****             ergodox_left_led_3_on();
 146:matrix.c      ****             break;
 147:matrix.c      ****         case 6:
 148:matrix.c      ****             ergodox_board_led_on();
 149:matrix.c      ****             // break missed intentionally
 150:matrix.c      ****         case 4:
 151:matrix.c      ****         case 5:
 152:matrix.c      ****         case 7:
 153:matrix.c      ****             // white
 154:matrix.c      ****             ergodox_left_led_1_on();
 155:matrix.c      ****             break;
 156:matrix.c      ****         case 9:
 157:matrix.c      ****             // white+green
 158:matrix.c      ****             ergodox_left_led_1_on();
 159:matrix.c      ****             ergodox_left_led_3_on();
 160:matrix.c      ****             break;
 161:matrix.c      ****         default:
 162:matrix.c      ****             // none
 163:matrix.c      ****             break;
 164:matrix.c      ****     }
 165:matrix.c      **** 
 166:matrix.c      ****     mcp23018_status = ergodox_left_leds_update();
 167:matrix.c      **** #endif
 168:matrix.c      **** 
 169:matrix.c      **** #ifdef KEYMAP_SIMON
 170:matrix.c      ****     uint8_t layer = biton32(layer_state);
 171:matrix.c      **** 
 172:matrix.c      ****     ergodox_board_led_off();
 173:matrix.c      ****     switch (layer) {
 174:matrix.c      ****         case 0:
 175:matrix.c      **** // none
 176:matrix.c      ****             
 177:matrix.c      ****             break;
 178:matrix.c      ****         default:
 179:matrix.c      ****             ergodox_board_led_on();
 180:matrix.c      ****             break;
 181:matrix.c      ****     }
 182:matrix.c      **** #endif
 183:matrix.c      **** 
 184:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 185:matrix.c      ****         select_row(i);
 186:matrix.c      ****         matrix_row_t cols = read_cols(i);
 187:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 188:matrix.c      ****             matrix_debouncing[i] = cols;
 189:matrix.c      ****             if (debouncing) {
 190:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 191:matrix.c      ****             }
 192:matrix.c      ****             debouncing = DEBOUNCE;
 193:matrix.c      ****         }
 194:matrix.c      ****         unselect_rows();
 195:matrix.c      ****     }
 196:matrix.c      **** 
 197:matrix.c      ****     if (debouncing) {
 198:matrix.c      ****         if (--debouncing) {
 199:matrix.c      ****             _delay_ms(1);
 200:matrix.c      ****         } else {
 201:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 202:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 203:matrix.c      ****             }
 204:matrix.c      ****         }
 205:matrix.c      ****     }
 206:matrix.c      **** 
 207:matrix.c      ****     return 1;
 208:matrix.c      **** }
 209:matrix.c      **** 
 210:matrix.c      **** bool matrix_is_modified(void)
 211:matrix.c      **** {
 212:matrix.c      ****     if (debouncing) return false;
 213:matrix.c      ****     return true;
 214:matrix.c      **** }
 215:matrix.c      **** 
 216:matrix.c      **** inline
 217:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 218:matrix.c      **** {
 219:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 220:matrix.c      **** }
 221:matrix.c      **** 
 222:matrix.c      **** inline
 223:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 224:matrix.c      **** {
 225:matrix.c      ****     return matrix[row];
 226:matrix.c      **** }
 227:matrix.c      **** 
 228:matrix.c      **** void matrix_print(void)
 229:matrix.c      **** {
 230:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 231:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 232:matrix.c      ****         phex(row); print(": ");
 233:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 234:matrix.c      ****         print("\n");
 235:matrix.c      ****     }
 236:matrix.c      **** }
 237:matrix.c      **** 
 238:matrix.c      **** uint8_t matrix_key_count(void)
 239:matrix.c      **** {
 240:matrix.c      ****     uint8_t count = 0;
 241:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 242:matrix.c      ****         count += bitpop16(matrix[i]);
 243:matrix.c      ****     }
 244:matrix.c      ****     return count;
 245:matrix.c      **** }
 246:matrix.c      **** 
 247:matrix.c      **** /* Column pin configuration
 248:matrix.c      ****  *
 249:matrix.c      ****  * Teensy
 250:matrix.c      ****  * col: 0   1   2   3   4   5
 251:matrix.c      ****  * pin: F0  F1  F4  F5  F6  F7 
 252:matrix.c      ****  *
 253:matrix.c      ****  * MCP23018
 254:matrix.c      ****  * col: 0   1   2   3   4   5
 255:matrix.c      ****  * pin: B5  B4  B3  B2  B1  B0 
 256:matrix.c      ****  */
 257:matrix.c      **** static void  init_cols(void)
 258:matrix.c      **** {
 259:matrix.c      ****     // init on mcp23018
 260:matrix.c      ****     // not needed, already done as part of init_mcp23018()
 261:matrix.c      **** 
 262:matrix.c      ****     // init on teensy
 263:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 264:matrix.c      ****     DDRF  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 265:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 266:matrix.c      **** }
 267:matrix.c      **** 
 268:matrix.c      **** static matrix_row_t read_cols(uint8_t row)
 269:matrix.c      **** {
 270:matrix.c      ****     if (row < 7) {
 271:matrix.c      ****         if (mcp23018_status) { // if there was an error
 272:matrix.c      ****             return 0;
 273:matrix.c      ****         } else {
 274:matrix.c      ****             uint8_t data = 0;
 275:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 276:matrix.c      ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 277:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 278:matrix.c      ****             data = i2c_readNak();
 279:matrix.c      ****             data = ~data;
 280:matrix.c      ****         out:
 281:matrix.c      ****             i2c_stop();
 282:matrix.c      ****             return data;
 283:matrix.c      ****         }
 284:matrix.c      ****     } else {
 285:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
 286:matrix.c      ****         // read from teensy
 287:matrix.c      ****         return
 288:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 289:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 290:matrix.c      ****             (PINF&(1<<4) ? 0 : (1<<2)) |
 291:matrix.c      ****             (PINF&(1<<5) ? 0 : (1<<3)) |
 292:matrix.c      ****             (PINF&(1<<6) ? 0 : (1<<4)) |
 293:matrix.c      ****             (PINF&(1<<7) ? 0 : (1<<5)) ;
 294:matrix.c      ****     }
 295:matrix.c      **** }
 296:matrix.c      **** 
 297:matrix.c      **** /* Row pin configuration
 298:matrix.c      ****  *
 299:matrix.c      ****  * Teensy
 300:matrix.c      ****  * row: 7   8   9   10  11  12  13
 301:matrix.c      ****  * pin: B0  B1  B2  B3  D2  D3  C6
 302:matrix.c      ****  *
 303:matrix.c      ****  * MCP23018
 304:matrix.c      ****  * row: 0   1   2   3   4   5   6
 305:matrix.c      ****  * pin: A0  A1  A2  A3  A4  A5  A6
 306:matrix.c      ****  */
 307:matrix.c      **** static void unselect_rows(void)
 308:matrix.c      **** {
  15               		.loc 1 308 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 309:matrix.c      ****     // unselect on mcp23018
 310:matrix.c      ****     if (mcp23018_status) { // if there was an error
  21               		.loc 1 310 0
  22 0000 8091 0000 		lds r24,mcp23018_status
  23 0004 8111      		cpse r24,__zero_reg__
  24 0006 00C0      		rjmp .L2
 311:matrix.c      ****         // do nothing
 312:matrix.c      ****     } else {
 313:matrix.c      ****         // set all rows hi-Z : 1
 314:matrix.c      ****         mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  25               		.loc 1 314 0
  26 0008 80E4      		ldi r24,lo8(64)
  27 000a 0E94 0000 		call i2c_start
  28               	.LVL0:
  29 000e 8093 0000 		sts mcp23018_status,r24
  30 0012 8111      		cpse r24,__zero_reg__
  31 0014 00C0      		rjmp .L4
 315:matrix.c      ****         mcp23018_status = i2c_write(GPIOA);             if (mcp23018_status) goto out;
  32               		.loc 1 315 0
  33 0016 82E1      		ldi r24,lo8(18)
  34 0018 0E94 0000 		call i2c_write
  35               	.LVL1:
  36 001c 8093 0000 		sts mcp23018_status,r24
  37 0020 8111      		cpse r24,__zero_reg__
  38 0022 00C0      		rjmp .L4
 316:matrix.c      ****         mcp23018_status = i2c_write( 0xFF
  39               		.loc 1 316 0
  40 0024 8091 0000 		lds r24,ergodox_left_led_3
  41 0028 8795      		ror r24
  42 002a 8827      		clr r24
  43 002c 8795      		ror r24
  44 002e 8095      		com r24
  45 0030 0E94 0000 		call i2c_write
  46               	.LVL2:
  47 0034 8093 0000 		sts mcp23018_status,r24
  48               	.L4:
 317:matrix.c      ****                               & ~(ergodox_left_led_3<<LEFT_LED_3_SHIFT)
 318:matrix.c      ****                           );                            if (mcp23018_status) goto out;
 319:matrix.c      ****     out:
 320:matrix.c      ****         i2c_stop();
  49               		.loc 1 320 0
  50 0038 0E94 0000 		call i2c_stop
  51               	.LVL3:
  52               	.L2:
 321:matrix.c      ****     }
 322:matrix.c      **** 
 323:matrix.c      ****     // unselect on teensy
 324:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 325:matrix.c      ****     DDRB  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  53               		.loc 1 325 0
  54 003c 84B1      		in r24,0x4
  55 003e 807F      		andi r24,lo8(-16)
  56 0040 84B9      		out 0x4,r24
 326:matrix.c      ****     PORTB &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
  57               		.loc 1 326 0
  58 0042 85B1      		in r24,0x5
  59 0044 807F      		andi r24,lo8(-16)
  60 0046 85B9      		out 0x5,r24
 327:matrix.c      ****     DDRD  &= ~(1<<2 | 1<<3);
  61               		.loc 1 327 0
  62 0048 8AB1      		in r24,0xa
  63 004a 837F      		andi r24,lo8(-13)
  64 004c 8AB9      		out 0xa,r24
 328:matrix.c      ****     PORTD &= ~(1<<2 | 1<<3);
  65               		.loc 1 328 0
  66 004e 8BB1      		in r24,0xb
  67 0050 837F      		andi r24,lo8(-13)
  68 0052 8BB9      		out 0xb,r24
 329:matrix.c      ****     DDRC  &= ~(1<<6);
  69               		.loc 1 329 0
  70 0054 3E98      		cbi 0x7,6
 330:matrix.c      ****     PORTC &= ~(1<<6);
  71               		.loc 1 330 0
  72 0056 4698      		cbi 0x8,6
  73 0058 0895      		ret
  74               		.cfi_endproc
  75               	.LFE43:
  77               		.section	.text.matrix_power_up,"ax",@progbits
  78               		.weak	matrix_power_up
  80               	matrix_power_up:
  81               	.LFB9:
  82               		.file 2 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  83               		.loc 2 65 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
  89 0000 0895      		ret
  90               		.cfi_endproc
  91               	.LFE9:
  93               		.section	.text.matrix_power_down,"ax",@progbits
  94               		.weak	matrix_power_down
  96               	matrix_power_down:
  97               	.LFB10:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  98               		.loc 2 66 0
  99               		.cfi_startproc
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* stack size = 0 */
 103               	.L__stack_usage = 0
 104 0000 0895      		ret
 105               		.cfi_endproc
 106               	.LFE10:
 108               		.section	.text.matrix_rows,"ax",@progbits
 109               	.global	matrix_rows
 111               	matrix_rows:
 112               	.LFB32:
  59:matrix.c      ****     return MATRIX_ROWS;
 113               		.loc 1 59 0
 114               		.cfi_startproc
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
  61:matrix.c      **** 
 119               		.loc 1 61 0
 120 0000 8EE0      		ldi r24,lo8(14)
 121 0002 0895      		ret
 122               		.cfi_endproc
 123               	.LFE32:
 125               		.section	.text.matrix_cols,"ax",@progbits
 126               	.global	matrix_cols
 128               	matrix_cols:
 129               	.LFB33:
  65:matrix.c      ****     return MATRIX_COLS;
 130               		.loc 1 65 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
  67:matrix.c      **** 
 136               		.loc 1 67 0
 137 0000 86E0      		ldi r24,lo8(6)
 138 0002 0895      		ret
 139               		.cfi_endproc
 140               	.LFE33:
 142               		.section	.text.matrix_init,"ax",@progbits
 143               	.global	matrix_init
 145               	matrix_init:
 146               	.LFB34:
  70:matrix.c      ****     // initialize row and col
 147               		.loc 1 70 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
  72:matrix.c      ****     mcp23018_status = init_mcp23018();
 153               		.loc 1 72 0
 154 0000 0E94 0000 		call init_ergodox
 155               	.LVL4:
  73:matrix.c      ****     ergodox_blink_all_leds();
 156               		.loc 1 73 0
 157 0004 0E94 0000 		call init_mcp23018
 158               	.LVL5:
 159 0008 8093 0000 		sts mcp23018_status,r24
  74:matrix.c      ****     unselect_rows();
 160               		.loc 1 74 0
 161 000c 0E94 0000 		call ergodox_blink_all_leds
 162               	.LVL6:
  75:matrix.c      ****     init_cols();
 163               		.loc 1 75 0
 164 0010 0E94 0000 		call unselect_rows
 165               	.LVL7:
 166               	.LBB27:
 167               	.LBB28:
 264:matrix.c      ****     PORTF |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<1 | 1<<0);
 168               		.loc 1 264 0
 169 0014 80B3      		in r24,0x10
 170 0016 8C70      		andi r24,lo8(12)
 171 0018 80BB      		out 0x10,r24
 265:matrix.c      **** }
 172               		.loc 1 265 0
 173 001a 81B3      		in r24,0x11
 174 001c 836F      		ori r24,lo8(-13)
 175 001e 81BB      		out 0x11,r24
 176               	.LVL8:
 177 0020 E0E0      		ldi r30,lo8(matrix)
 178 0022 F0E0      		ldi r31,hi8(matrix)
 179 0024 A0E0      		ldi r26,lo8(matrix_debouncing)
 180 0026 B0E0      		ldi r27,hi8(matrix_debouncing)
 181               	.LVL9:
 182               	.L13:
 183               	.LBE28:
 184               	.LBE27:
 185               	.LBB29:
  80:matrix.c      ****         matrix_debouncing[i] = 0;
 186               		.loc 1 80 0 discriminator 2
 187 0028 1192      		st Z+,__zero_reg__
 188               	.LVL10:
  81:matrix.c      ****     }
 189               		.loc 1 81 0 discriminator 2
 190 002a 1D92      		st X+,__zero_reg__
 191               	.LVL11:
  79:matrix.c      ****         matrix[i] = 0;
 192               		.loc 1 79 0 discriminator 2
 193 002c 80E0      		ldi r24,hi8(matrix+14)
 194 002e E030      		cpi r30,lo8(matrix+14)
 195 0030 F807      		cpc r31,r24
 196 0032 01F4      		brne .L13
 197               	/* epilogue start */
 198               	.LBE29:
  88:matrix.c      **** 
 199               		.loc 1 88 0
 200 0034 0895      		ret
 201               		.cfi_endproc
 202               	.LFE34:
 204               		.section	.text.matrix_scan,"ax",@progbits
 205               	.global	matrix_scan
 207               	matrix_scan:
 208               	.LFB35:
  91:matrix.c      ****     if (mcp23018_status) { // if there was an error
 209               		.loc 1 91 0
 210               		.cfi_startproc
 211 0000 9F92      		push r9
 212               	.LCFI0:
 213               		.cfi_def_cfa_offset 3
 214               		.cfi_offset 9, -2
 215 0002 AF92      		push r10
 216               	.LCFI1:
 217               		.cfi_def_cfa_offset 4
 218               		.cfi_offset 10, -3
 219 0004 BF92      		push r11
 220               	.LCFI2:
 221               		.cfi_def_cfa_offset 5
 222               		.cfi_offset 11, -4
 223 0006 CF92      		push r12
 224               	.LCFI3:
 225               		.cfi_def_cfa_offset 6
 226               		.cfi_offset 12, -5
 227 0008 DF92      		push r13
 228               	.LCFI4:
 229               		.cfi_def_cfa_offset 7
 230               		.cfi_offset 13, -6
 231 000a EF92      		push r14
 232               	.LCFI5:
 233               		.cfi_def_cfa_offset 8
 234               		.cfi_offset 14, -7
 235 000c FF92      		push r15
 236               	.LCFI6:
 237               		.cfi_def_cfa_offset 9
 238               		.cfi_offset 15, -8
 239 000e 0F93      		push r16
 240               	.LCFI7:
 241               		.cfi_def_cfa_offset 10
 242               		.cfi_offset 16, -9
 243 0010 1F93      		push r17
 244               	.LCFI8:
 245               		.cfi_def_cfa_offset 11
 246               		.cfi_offset 17, -10
 247 0012 CF93      		push r28
 248               	.LCFI9:
 249               		.cfi_def_cfa_offset 12
 250               		.cfi_offset 28, -11
 251 0014 DF93      		push r29
 252               	.LCFI10:
 253               		.cfi_def_cfa_offset 13
 254               		.cfi_offset 29, -12
 255               	/* prologue: function */
 256               	/* frame size = 0 */
 257               	/* stack size = 11 */
 258               	.L__stack_usage = 11
  92:matrix.c      ****         if (++mcp23018_reset_loop == 0) {
 259               		.loc 1 92 0
 260 0016 8091 0000 		lds r24,mcp23018_status
 261 001a 8823      		tst r24
 262 001c 01F0      		breq .L16
  93:matrix.c      ****             // since mcp23018_reset_loop is 8 bit - we'll try to reset once in 255 matrix scans
 263               		.loc 1 93 0
 264 001e 8091 0000 		lds r24,mcp23018_reset_loop
 265 0022 8F5F      		subi r24,lo8(-(1))
 266 0024 8093 0000 		sts mcp23018_reset_loop,r24
 267 0028 8111      		cpse r24,__zero_reg__
 268 002a 00C0      		rjmp .L16
  96:matrix.c      ****             mcp23018_status = init_mcp23018();
 269               		.loc 1 96 0
 270 002c 80E0      		ldi r24,lo8(__c.2446)
 271 002e 90E0      		ldi r25,hi8(__c.2446)
 272 0030 0E94 0000 		call xputs
 273               	.LVL12:
  97:matrix.c      ****             if (mcp23018_status) {
 274               		.loc 1 97 0
 275 0034 0E94 0000 		call init_mcp23018
 276               	.LVL13:
 277 0038 8093 0000 		sts mcp23018_status,r24
  98:matrix.c      ****                 print("left side not responding\n");
 278               		.loc 1 98 0
 279 003c 8823      		tst r24
 280 003e 01F0      		breq .L18
  99:matrix.c      ****             } else {
 281               		.loc 1 99 0
 282 0040 80E0      		ldi r24,lo8(__c.2448)
 283 0042 90E0      		ldi r25,hi8(__c.2448)
 284 0044 0E94 0000 		call xputs
 285               	.LVL14:
 286 0048 00C0      		rjmp .L16
 287               	.L18:
 101:matrix.c      ****                 ergodox_blink_all_leds();
 288               		.loc 1 101 0
 289 004a 80E0      		ldi r24,lo8(__c.2450)
 290 004c 90E0      		ldi r25,hi8(__c.2450)
 291 004e 0E94 0000 		call xputs
 292               	.LVL15:
 102:matrix.c      ****             }
 293               		.loc 1 102 0
 294 0052 0E94 0000 		call ergodox_blink_all_leds
 295               	.LVL16:
 296               	.L16:
  91:matrix.c      ****     if (mcp23018_status) { // if there was an error
 297               		.loc 1 91 0 discriminator 1
 298 0056 00E0      		ldi r16,lo8(matrix_debouncing)
 299 0058 10E0      		ldi r17,hi8(matrix_debouncing)
 300 005a C0E0      		ldi r28,0
 301 005c D0E0      		ldi r29,0
 302 005e BB24      		clr r11
 303 0060 B394      		inc r11
 304               	.LBB48:
 305               	.LBB49:
 306               	.LBB50:
 307               	.LBB51:
 287:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 308               		.loc 1 287 0 discriminator 1
 309 0062 82E0      		ldi r24,lo8(2)
 310 0064 A82E      		mov r10,r24
 311               	.LBE51:
 312               	.LBE50:
 313               	.LBB58:
 314               	.LBB59:
 331:matrix.c      **** }
 332:matrix.c      **** 
 333:matrix.c      **** static void select_row(uint8_t row)
 334:matrix.c      **** {
 335:matrix.c      ****     if (row < 7) {
 336:matrix.c      ****         // select on mcp23018
 337:matrix.c      ****         if (mcp23018_status) { // if there was an error
 338:matrix.c      ****             // do nothing
 339:matrix.c      ****         } else {
 340:matrix.c      ****             // set active row low  : 0
 341:matrix.c      ****             // set other rows hi-Z : 1
 342:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);        if (mcp23018_status) goto out;
 343:matrix.c      ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 344:matrix.c      ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row) 
 315               		.loc 1 344 0 discriminator 1
 316 0066 CC24      		clr r12
 317 0068 C394      		inc r12
 318 006a D12C      		mov r13,__zero_reg__
 319               	.LBE59:
 320               	.LBE58:
 190:matrix.c      ****             }
 321               		.loc 1 190 0 discriminator 1
 322 006c 20E0      		ldi r18,lo8(__c.2456)
 323 006e E22E      		mov r14,r18
 324 0070 20E0      		ldi r18,hi8(__c.2456)
 325 0072 F22E      		mov r15,r18
 326               	.LVL17:
 327               	.L48:
 328               	.LBB61:
 329               	.LBB60:
 335:matrix.c      ****         // select on mcp23018
 330               		.loc 1 335 0
 331 0074 C730      		cpi r28,lo8(7)
 332 0076 00F4      		brsh .L19
 337:matrix.c      ****             // do nothing
 333               		.loc 1 337 0
 334 0078 8091 0000 		lds r24,mcp23018_status
 335 007c 8111      		cpse r24,__zero_reg__
 336 007e 00C0      		rjmp .L20
 342:matrix.c      ****             mcp23018_status = i2c_write(GPIOA);                 if (mcp23018_status) goto out;
 337               		.loc 1 342 0
 338 0080 80E4      		ldi r24,lo8(64)
 339 0082 0E94 0000 		call i2c_start
 340               	.LVL18:
 341 0086 8093 0000 		sts mcp23018_status,r24
 342 008a 8111      		cpse r24,__zero_reg__
 343 008c 00C0      		rjmp .L22
 343:matrix.c      ****             mcp23018_status = i2c_write( 0xFF & ~(1<<row) 
 344               		.loc 1 343 0
 345 008e 82E1      		ldi r24,lo8(18)
 346 0090 0E94 0000 		call i2c_write
 347               	.LVL19:
 348 0094 8093 0000 		sts mcp23018_status,r24
 349 0098 8111      		cpse r24,__zero_reg__
 350 009a 00C0      		rjmp .L22
 351               		.loc 1 344 0
 352 009c 8091 0000 		lds r24,ergodox_left_led_3
 353 00a0 8795      		ror r24
 354 00a2 8827      		clr r24
 355 00a4 8795      		ror r24
 356 00a6 9601      		movw r18,r12
 357 00a8 0C2E      		mov r0,r28
 358 00aa 00C0      		rjmp 2f
 359               		1:
 360 00ac 220F      		lsl r18
 361               		2:
 362 00ae 0A94      		dec r0
 363 00b0 02F4      		brpl 1b
 364 00b2 822B      		or r24,r18
 365 00b4 8095      		com r24
 366 00b6 0E94 0000 		call i2c_write
 367               	.LVL20:
 368 00ba 8093 0000 		sts mcp23018_status,r24
 369               	.L22:
 345:matrix.c      ****                                   & ~(ergodox_left_led_3<<LEFT_LED_3_SHIFT)
 346:matrix.c      ****                               );                                if (mcp23018_status) goto out;
 347:matrix.c      ****         out:
 348:matrix.c      ****             i2c_stop();
 370               		.loc 1 348 0
 371 00be 0E94 0000 		call i2c_stop
 372               	.LVL21:
 373 00c2 00C0      		rjmp .L20
 374               	.L19:
 349:matrix.c      ****         }
 350:matrix.c      ****     } else {
 351:matrix.c      ****         // select on teensy
 352:matrix.c      ****         // Output low(DDR:1, PORT:0) to select
 353:matrix.c      ****         switch (row) {
 375               		.loc 1 353 0
 376 00c4 CA30      		cpi r28,lo8(10)
 377 00c6 01F0      		breq .L25
 378 00c8 00F4      		brsh .L26
 379 00ca C830      		cpi r28,lo8(8)
 380 00cc 01F0      		breq .L27
 381 00ce C930      		cpi r28,lo8(9)
 382 00d0 01F0      		breq .L28
 383 00d2 00C0      		rjmp .L24
 384               	.L26:
 385 00d4 CC30      		cpi r28,lo8(12)
 386 00d6 01F0      		breq .L29
 387 00d8 00F0      		brlo .L30
 388 00da CD30      		cpi r28,lo8(13)
 389 00dc 01F0      		breq .L31
 390               	.L24:
 354:matrix.c      ****             case 7:
 355:matrix.c      ****                 DDRB  |= (1<<0);
 391               		.loc 1 355 0
 392 00de 209A      		sbi 0x4,0
 356:matrix.c      ****                 PORTB &= ~(1<<0);
 393               		.loc 1 356 0
 394 00e0 2898      		cbi 0x5,0
 395 00e2 00C0      		rjmp .L32
 396               	.L27:
 357:matrix.c      ****                 break;
 358:matrix.c      ****             case 8:
 359:matrix.c      ****                 DDRB  |= (1<<1);
 397               		.loc 1 359 0
 398 00e4 219A      		sbi 0x4,1
 360:matrix.c      ****                 PORTB &= ~(1<<1);
 399               		.loc 1 360 0
 400 00e6 2998      		cbi 0x5,1
 401 00e8 00C0      		rjmp .L32
 402               	.L28:
 361:matrix.c      ****                 break;
 362:matrix.c      ****             case 9:
 363:matrix.c      ****                 DDRB  |= (1<<2);
 403               		.loc 1 363 0
 404 00ea 229A      		sbi 0x4,2
 364:matrix.c      ****                 PORTB &= ~(1<<2);
 405               		.loc 1 364 0
 406 00ec 2A98      		cbi 0x5,2
 407 00ee 00C0      		rjmp .L32
 408               	.L25:
 365:matrix.c      ****                 break;
 366:matrix.c      ****             case 10:
 367:matrix.c      ****                 DDRB  |= (1<<3);
 409               		.loc 1 367 0
 410 00f0 239A      		sbi 0x4,3
 368:matrix.c      ****                 PORTB &= ~(1<<3);
 411               		.loc 1 368 0
 412 00f2 2B98      		cbi 0x5,3
 413 00f4 00C0      		rjmp .L32
 414               	.L30:
 369:matrix.c      ****                 break;
 370:matrix.c      ****             case 11:
 371:matrix.c      ****                 DDRD  |= (1<<2);
 415               		.loc 1 371 0
 416 00f6 529A      		sbi 0xa,2
 417 00f8 00C0      		rjmp .L75
 418               	.L29:
 372:matrix.c      ****                 PORTD &= ~(1<<3);
 373:matrix.c      ****                 break;
 374:matrix.c      ****             case 12:
 375:matrix.c      ****                 DDRD  |= (1<<3);
 419               		.loc 1 375 0
 420 00fa 539A      		sbi 0xa,3
 421               	.L75:
 376:matrix.c      ****                 PORTD &= ~(1<<3);
 422               		.loc 1 376 0
 423 00fc 5B98      		cbi 0xb,3
 424 00fe 00C0      		rjmp .L32
 425               	.L31:
 377:matrix.c      ****                 break;
 378:matrix.c      ****             case 13:
 379:matrix.c      ****                 DDRC  |= (1<<6);
 426               		.loc 1 379 0
 427 0100 3E9A      		sbi 0x7,6
 380:matrix.c      ****                 PORTC &= ~(1<<6);
 428               		.loc 1 380 0
 429 0102 4698      		cbi 0x8,6
 430               	.L32:
 431               	.LVL22:
 432               	.LBE60:
 433               	.LBE61:
 434               	.LBB62:
 435               	.LBB56:
 436               	.LBB52:
 437               	.LBB53:
 438               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 439               		.loc 3 245 0
 440 0104 E0EA      		ldi r30,lo8(-96)
 441 0106 EA95      		1: dec r30
 442 0108 01F4      		brne 1b
 443               	.LBE53:
 444               	.LBE52:
 288:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 445               		.loc 1 288 0
 446 010a 8FB1      		in r24,0xf
 287:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 447               		.loc 1 287 0
 448 010c 7999      		sbic 0xf,1
 449 010e 00C0      		rjmp .L76
 450 0110 92E0      		ldi r25,lo8(2)
 451               	.L54:
 288:matrix.c      ****             (PINF&(1<<1) ? 0 : (1<<1)) |
 452               		.loc 1 288 0
 453 0112 8170      		andi r24,lo8(1)
 454 0114 8B25      		eor r24,r11
 287:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 455               		.loc 1 287 0
 456 0116 892B      		or r24,r25
 457 0118 7C9B      		sbis 0xf,4
 458 011a 00C0      		rjmp .L56
 459 011c 90E0      		ldi r25,0
 460 011e 00C0      		rjmp .L37
 461               	.L56:
 462 0120 94E0      		ldi r25,lo8(4)
 463               	.L37:
 464 0122 892B      		or r24,r25
 465 0124 7D9B      		sbis 0xf,5
 466 0126 00C0      		rjmp .L57
 467 0128 90E0      		ldi r25,0
 468 012a 00C0      		rjmp .L38
 469               	.L57:
 470 012c 98E0      		ldi r25,lo8(8)
 471               	.L38:
 472 012e 892B      		or r24,r25
 473 0130 7E9B      		sbis 0xf,6
 474 0132 00C0      		rjmp .L58
 475 0134 90E0      		ldi r25,0
 476 0136 00C0      		rjmp .L39
 477               	.L58:
 478 0138 90E1      		ldi r25,lo8(16)
 479               	.L39:
 480 013a 892B      		or r24,r25
 293:matrix.c      ****     }
 481               		.loc 1 293 0
 482 013c 9FB1      		in r25,0xf
 287:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 483               		.loc 1 287 0
 484 013e 9095      		com r25
 485 0140 991F      		rol r25
 486 0142 9927      		clr r25
 487 0144 991F      		rol r25
 488 0146 9295      		swap r25
 489 0148 990F      		lsl r25
 490 014a 907E      		andi r25,lo8(-32)
 491 014c 892B      		or r24,r25
 492 014e 00C0      		rjmp .L36
 493               	.LVL23:
 494               	.L20:
 271:matrix.c      ****             return 0;
 495               		.loc 1 271 0
 496 0150 8091 0000 		lds r24,mcp23018_status
 497 0154 8111      		cpse r24,__zero_reg__
 498 0156 00C0      		rjmp .L61
 499               	.LVL24:
 500               	.LBB54:
 275:matrix.c      ****             mcp23018_status = i2c_write(GPIOB);             if (mcp23018_status) goto out;
 501               		.loc 1 275 0
 502 0158 80E4      		ldi r24,lo8(64)
 503 015a 0E94 0000 		call i2c_start
 504               	.LVL25:
 505 015e 8093 0000 		sts mcp23018_status,r24
 506 0162 8823      		tst r24
 507 0164 01F4      		brne .+2
 508 0166 00C0      		rjmp .L33
 509               	.L35:
 274:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 510               		.loc 1 274 0
 511 0168 912C      		mov r9,__zero_reg__
 512               	.LVL26:
 513               	.L34:
 281:matrix.c      ****             return data;
 514               		.loc 1 281 0
 515 016a 0E94 0000 		call i2c_stop
 516               	.LVL27:
 282:matrix.c      ****         }
 517               		.loc 1 282 0
 518 016e 892D      		mov r24,r9
 519               	.LVL28:
 520               	.L36:
 521               	.LBE54:
 522               	.LBE56:
 523               	.LBE62:
 187:matrix.c      ****             matrix_debouncing[i] = cols;
 524               		.loc 1 187 0
 525 0170 F801      		movw r30,r16
 526 0172 9081      		ld r25,Z
 527 0174 9817      		cp r25,r24
 528 0176 01F0      		breq .L41
 188:matrix.c      ****             if (debouncing) {
 529               		.loc 1 188 0
 530 0178 8083      		st Z,r24
 189:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 531               		.loc 1 189 0
 532 017a 8091 0000 		lds r24,debouncing
 533 017e 8823      		tst r24
 534 0180 01F0      		breq .L43
 190:matrix.c      ****             }
 535               		.loc 1 190 0
 536 0182 8091 0000 		lds r24,debug_config
 537 0186 80FF      		sbrs r24,0
 538 0188 00C0      		rjmp .L44
 190:matrix.c      ****             }
 539               		.loc 1 190 0 is_stmt 0 discriminator 1
 540 018a 80E0      		ldi r24,lo8(__c.2454)
 541 018c 90E0      		ldi r25,hi8(__c.2454)
 542 018e 0E94 0000 		call xputs
 543               	.LVL29:
 544               	.L44:
 190:matrix.c      ****             }
 545               		.loc 1 190 0 discriminator 2
 546 0192 8091 0000 		lds r24,debug_config
 547 0196 80FF      		sbrs r24,0
 548 0198 00C0      		rjmp .L45
 190:matrix.c      ****             }
 549               		.loc 1 190 0 discriminator 1
 550 019a 8091 0000 		lds r24,debouncing
 551 019e 1F92      		push __zero_reg__
 552               	.LCFI11:
 553               		.cfi_def_cfa_offset 14
 554 01a0 8F93      		push r24
 555               	.LCFI12:
 556               		.cfi_def_cfa_offset 15
 557 01a2 FF92      		push r15
 558               	.LCFI13:
 559               		.cfi_def_cfa_offset 16
 560 01a4 EF92      		push r14
 561               	.LCFI14:
 562               		.cfi_def_cfa_offset 17
 563 01a6 0E94 0000 		call __xprintf
 564               	.LVL30:
 565 01aa 0F90      		pop __tmp_reg__
 566 01ac 0F90      		pop __tmp_reg__
 567 01ae 0F90      		pop __tmp_reg__
 568 01b0 0F90      		pop __tmp_reg__
 569               	.LCFI15:
 570               		.cfi_def_cfa_offset 13
 571               	.L45:
 190:matrix.c      ****             }
 572               		.loc 1 190 0 discriminator 2
 573 01b2 8091 0000 		lds r24,debug_config
 574 01b6 80FF      		sbrs r24,0
 575 01b8 00C0      		rjmp .L43
 190:matrix.c      ****             }
 576               		.loc 1 190 0 discriminator 1
 577 01ba 80E0      		ldi r24,lo8(__c.2458)
 578 01bc 90E0      		ldi r25,hi8(__c.2458)
 579 01be 0E94 0000 		call xputs
 580               	.LVL31:
 581               	.L43:
 192:matrix.c      ****         }
 582               		.loc 1 192 0 is_stmt 1
 583 01c2 A092 0000 		sts debouncing,r10
 584               	.L41:
 194:matrix.c      ****     }
 585               		.loc 1 194 0
 586 01c6 0E94 0000 		call unselect_rows
 587               	.LVL32:
 588 01ca 2196      		adiw r28,1
 589               	.LVL33:
 590 01cc 0F5F      		subi r16,-1
 591 01ce 1F4F      		sbci r17,-1
 592               	.LBE49:
 184:matrix.c      ****         select_row(i);
 593               		.loc 1 184 0
 594 01d0 CE30      		cpi r28,14
 595 01d2 D105      		cpc r29,__zero_reg__
 596 01d4 01F0      		breq .+2
 597 01d6 00C0      		rjmp .L48
 598               	.LBE48:
 197:matrix.c      ****         if (--debouncing) {
 599               		.loc 1 197 0
 600 01d8 8091 0000 		lds r24,debouncing
 601 01dc 8823      		tst r24
 602 01de 01F0      		breq .L65
 198:matrix.c      ****             _delay_ms(1);
 603               		.loc 1 198 0
 604 01e0 8150      		subi r24,lo8(-(-1))
 605 01e2 8093 0000 		sts debouncing,r24
 606 01e6 8823      		tst r24
 607 01e8 01F0      		breq .L51
 608               	.LVL34:
 609               	.LBB65:
 610               	.LBB66:
 163:/usr/lib/avr/include/util/delay.h **** 
 611               		.loc 3 163 0
 612 01ea 8FE9      		ldi r24,lo8(3999)
 613 01ec 9FE0      		ldi r25,hi8(3999)
 614 01ee 0197      		1: sbiw r24,1
 615 01f0 01F4      		brne 1b
 616 01f2 00C0      		rjmp .
 617 01f4 0000      		nop
 618 01f6 00C0      		rjmp .L65
 619               	.LVL35:
 620               	.L51:
 621 01f8 A0E0      		ldi r26,lo8(matrix)
 622 01fa B0E0      		ldi r27,hi8(matrix)
 623               	.LBE66:
 624               	.LBE65:
 198:matrix.c      ****             _delay_ms(1);
 625               		.loc 1 198 0
 626 01fc E0E0      		ldi r30,lo8(matrix_debouncing)
 627 01fe F0E0      		ldi r31,hi8(matrix_debouncing)
 628               	.L53:
 629               	.LVL36:
 630               	.LBB67:
 202:matrix.c      ****             }
 631               		.loc 1 202 0 discriminator 2
 632 0200 8191      		ld r24,Z+
 633               	.LVL37:
 634 0202 8D93      		st X+,r24
 635               	.LVL38:
 201:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 636               		.loc 1 201 0 discriminator 2
 637 0204 90E0      		ldi r25,hi8(matrix_debouncing+14)
 638 0206 E030      		cpi r30,lo8(matrix_debouncing+14)
 639 0208 F907      		cpc r31,r25
 640 020a 01F4      		brne .L53
 641 020c 00C0      		rjmp .L65
 642               	.LVL39:
 643               	.L76:
 644               	.LBE67:
 645               	.LBB68:
 646               	.LBB64:
 647               	.LBB63:
 648               	.LBB57:
 287:matrix.c      ****             (PINF&(1<<0) ? 0 : (1<<0)) |
 649               		.loc 1 287 0
 650 020e 90E0      		ldi r25,0
 651 0210 00C0      		rjmp .L54
 652               	.LVL40:
 653               	.L33:
 654               	.LBB55:
 276:matrix.c      ****             mcp23018_status = i2c_start(I2C_ADDR_READ);     if (mcp23018_status) goto out;
 655               		.loc 1 276 0
 656 0212 83E1      		ldi r24,lo8(19)
 657 0214 0E94 0000 		call i2c_write
 658               	.LVL41:
 659 0218 8093 0000 		sts mcp23018_status,r24
 660 021c 8111      		cpse r24,__zero_reg__
 661 021e 00C0      		rjmp .L35
 277:matrix.c      ****             data = i2c_readNak();
 662               		.loc 1 277 0
 663 0220 81E4      		ldi r24,lo8(65)
 664 0222 0E94 0000 		call i2c_start
 665               	.LVL42:
 666 0226 8093 0000 		sts mcp23018_status,r24
 667 022a 8111      		cpse r24,__zero_reg__
 668 022c 00C0      		rjmp .L35
 278:matrix.c      ****             data = ~data;
 669               		.loc 1 278 0
 670 022e 0E94 0000 		call i2c_readNak
 671               	.LVL43:
 279:matrix.c      ****         out:
 672               		.loc 1 279 0
 673 0232 982E      		mov r9,r24
 674 0234 9094      		com r9
 675               	.LVL44:
 676 0236 00C0      		rjmp .L34
 677               	.LVL45:
 678               	.L61:
 679               	.LBE55:
 272:matrix.c      ****         } else {
 680               		.loc 1 272 0
 681 0238 80E0      		ldi r24,0
 682 023a 00C0      		rjmp .L36
 683               	.LVL46:
 684               	.L65:
 685               	.LBE57:
 686               	.LBE63:
 687               	.LBE64:
 688               	.LBE68:
 208:matrix.c      **** 
 689               		.loc 1 208 0
 690 023c 81E0      		ldi r24,lo8(1)
 691               	/* epilogue start */
 692 023e DF91      		pop r29
 693 0240 CF91      		pop r28
 694               	.LVL47:
 695 0242 1F91      		pop r17
 696 0244 0F91      		pop r16
 697 0246 FF90      		pop r15
 698 0248 EF90      		pop r14
 699 024a DF90      		pop r13
 700 024c CF90      		pop r12
 701 024e BF90      		pop r11
 702 0250 AF90      		pop r10
 703 0252 9F90      		pop r9
 704 0254 0895      		ret
 705               		.cfi_endproc
 706               	.LFE35:
 708               		.section	.text.matrix_is_modified,"ax",@progbits
 709               	.global	matrix_is_modified
 711               	matrix_is_modified:
 712               	.LFB36:
 211:matrix.c      ****     if (debouncing) return false;
 713               		.loc 1 211 0
 714               		.cfi_startproc
 715               	/* prologue: function */
 716               	/* frame size = 0 */
 717               	/* stack size = 0 */
 718               	.L__stack_usage = 0
 212:matrix.c      ****     return true;
 719               		.loc 1 212 0
 720 0000 81E0      		ldi r24,lo8(1)
 721 0002 9091 0000 		lds r25,debouncing
 722 0006 9111      		cpse r25,__zero_reg__
 723 0008 80E0      		ldi r24,0
 724               	.L78:
 214:matrix.c      **** 
 725               		.loc 1 214 0
 726 000a 0895      		ret
 727               		.cfi_endproc
 728               	.LFE36:
 730               		.section	.text.matrix_is_on,"ax",@progbits
 731               	.global	matrix_is_on
 733               	matrix_is_on:
 734               	.LFB37:
 218:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 735               		.loc 1 218 0
 736               		.cfi_startproc
 737               	.LVL48:
 738               	/* prologue: function */
 739               	/* frame size = 0 */
 740               	/* stack size = 0 */
 741               	.L__stack_usage = 0
 219:matrix.c      **** }
 742               		.loc 1 219 0
 743 0000 E82F      		mov r30,r24
 744 0002 F0E0      		ldi r31,0
 745 0004 E050      		subi r30,lo8(-(matrix))
 746 0006 F040      		sbci r31,hi8(-(matrix))
 747 0008 2081      		ld r18,Z
 748 000a 30E0      		ldi r19,0
 749 000c 81E0      		ldi r24,lo8(1)
 750 000e 90E0      		ldi r25,0
 751               	.LVL49:
 752 0010 00C0      		rjmp 2f
 753               		1:
 754 0012 880F      		lsl r24
 755 0014 991F      		rol r25
 756               		2:
 757 0016 6A95      		dec r22
 758 0018 02F4      		brpl 1b
 759 001a 2823      		and r18,r24
 760 001c 3923      		and r19,r25
 761 001e 81E0      		ldi r24,lo8(1)
 762 0020 232B      		or r18,r19
 763 0022 01F4      		brne .L83
 764 0024 80E0      		ldi r24,0
 765               	.L83:
 220:matrix.c      **** 
 766               		.loc 1 220 0
 767 0026 0895      		ret
 768               		.cfi_endproc
 769               	.LFE37:
 771               		.section	.text.matrix_get_row,"ax",@progbits
 772               	.global	matrix_get_row
 774               	matrix_get_row:
 775               	.LFB38:
 224:matrix.c      ****     return matrix[row];
 776               		.loc 1 224 0
 777               		.cfi_startproc
 778               	.LVL50:
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 225:matrix.c      **** }
 783               		.loc 1 225 0
 784 0000 E82F      		mov r30,r24
 785 0002 F0E0      		ldi r31,0
 786 0004 E050      		subi r30,lo8(-(matrix))
 787 0006 F040      		sbci r31,hi8(-(matrix))
 226:matrix.c      **** 
 788               		.loc 1 226 0
 789 0008 8081      		ld r24,Z
 790               	.LVL51:
 791 000a 0895      		ret
 792               		.cfi_endproc
 793               	.LFE38:
 795               		.section	.text.matrix_print,"ax",@progbits
 796               	.global	matrix_print
 798               	matrix_print:
 799               	.LFB39:
 229:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 800               		.loc 1 229 0
 801               		.cfi_startproc
 802 0000 CF92      		push r12
 803               	.LCFI16:
 804               		.cfi_def_cfa_offset 3
 805               		.cfi_offset 12, -2
 806 0002 DF92      		push r13
 807               	.LCFI17:
 808               		.cfi_def_cfa_offset 4
 809               		.cfi_offset 13, -3
 810 0004 EF92      		push r14
 811               	.LCFI18:
 812               		.cfi_def_cfa_offset 5
 813               		.cfi_offset 14, -4
 814 0006 FF92      		push r15
 815               	.LCFI19:
 816               		.cfi_def_cfa_offset 6
 817               		.cfi_offset 15, -5
 818 0008 0F93      		push r16
 819               	.LCFI20:
 820               		.cfi_def_cfa_offset 7
 821               		.cfi_offset 16, -6
 822 000a 1F93      		push r17
 823               	.LCFI21:
 824               		.cfi_def_cfa_offset 8
 825               		.cfi_offset 17, -7
 826 000c CF93      		push r28
 827               	.LCFI22:
 828               		.cfi_def_cfa_offset 9
 829               		.cfi_offset 28, -8
 830 000e DF93      		push r29
 831               	.LCFI23:
 832               		.cfi_def_cfa_offset 10
 833               		.cfi_offset 29, -9
 834               	/* prologue: function */
 835               	/* frame size = 0 */
 836               	/* stack size = 8 */
 837               	.L__stack_usage = 8
 230:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 838               		.loc 1 230 0
 839 0010 80E0      		ldi r24,lo8(__c.2480)
 840 0012 90E0      		ldi r25,hi8(__c.2480)
 841 0014 0E94 0000 		call xputs
 842 0018 30E0      		ldi r19,lo8(matrix)
 843 001a E32E      		mov r14,r19
 844 001c 30E0      		ldi r19,hi8(matrix)
 845 001e F32E      		mov r15,r19
 846 0020 C0E0      		ldi r28,0
 847 0022 D0E0      		ldi r29,0
 848               	.LBB69:
 232:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 849               		.loc 1 232 0
 850 0024 40E0      		ldi r20,lo8(__c.2483)
 851 0026 C42E      		mov r12,r20
 852 0028 40E0      		ldi r20,hi8(__c.2483)
 853 002a D42E      		mov r13,r20
 233:matrix.c      ****         print("\n");
 854               		.loc 1 233 0
 855 002c 00E0      		ldi r16,lo8(__c.2487)
 856 002e 10E0      		ldi r17,hi8(__c.2487)
 857               	.L87:
 232:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 858               		.loc 1 232 0 discriminator 2
 859 0030 DF93      		push r29
 860               	.LCFI24:
 861               		.cfi_def_cfa_offset 11
 862 0032 CF93      		push r28
 863               	.LCFI25:
 864               		.cfi_def_cfa_offset 12
 865 0034 DF92      		push r13
 866               	.LCFI26:
 867               		.cfi_def_cfa_offset 13
 868 0036 CF92      		push r12
 869               	.LCFI27:
 870               		.cfi_def_cfa_offset 14
 871 0038 0E94 0000 		call __xprintf
 872 003c 80E0      		ldi r24,lo8(__c.2485)
 873 003e 90E0      		ldi r25,hi8(__c.2485)
 874 0040 0E94 0000 		call xputs
 875               	.LBB70:
 876               	.LBB71:
 225:matrix.c      **** }
 877               		.loc 1 225 0 discriminator 2
 878 0044 F701      		movw r30,r14
 879 0046 8191      		ld r24,Z+
 880 0048 7F01      		movw r14,r30
 881               	.LBE71:
 882               	.LBE70:
 233:matrix.c      ****         print("\n");
 883               		.loc 1 233 0 discriminator 2
 884 004a 90E0      		ldi r25,0
 885 004c 0E94 0000 		call bitrev16
 886 0050 9F93      		push r25
 887               	.LCFI28:
 888               		.cfi_def_cfa_offset 15
 889 0052 8F93      		push r24
 890               	.LCFI29:
 891               		.cfi_def_cfa_offset 16
 892 0054 1F93      		push r17
 893               	.LCFI30:
 894               		.cfi_def_cfa_offset 17
 895 0056 0F93      		push r16
 896               	.LCFI31:
 897               		.cfi_def_cfa_offset 18
 898 0058 0E94 0000 		call __xprintf
 234:matrix.c      ****     }
 899               		.loc 1 234 0 discriminator 2
 900 005c 80E0      		ldi r24,lo8(__c.2489)
 901 005e 90E0      		ldi r25,hi8(__c.2489)
 902 0060 0E94 0000 		call xputs
 903 0064 2196      		adiw r28,1
 231:matrix.c      ****         phex(row); print(": ");
 904               		.loc 1 231 0 discriminator 2
 905 0066 8DB7      		in r24,__SP_L__
 906 0068 9EB7      		in r25,__SP_H__
 907 006a 0896      		adiw r24,8
 908 006c 0FB6      		in __tmp_reg__,__SREG__
 909 006e F894      		cli
 910 0070 9EBF      		out __SP_H__,r25
 911 0072 0FBE      		out __SREG__,__tmp_reg__
 912 0074 8DBF      		out __SP_L__,r24
 913               	.LCFI32:
 914               		.cfi_def_cfa_offset 10
 915 0076 CE30      		cpi r28,14
 916 0078 D105      		cpc r29,__zero_reg__
 917 007a 01F4      		brne .L87
 918               	/* epilogue start */
 919               	.LBE69:
 236:matrix.c      **** 
 920               		.loc 1 236 0
 921 007c DF91      		pop r29
 922 007e CF91      		pop r28
 923 0080 1F91      		pop r17
 924 0082 0F91      		pop r16
 925 0084 FF90      		pop r15
 926 0086 EF90      		pop r14
 927 0088 DF90      		pop r13
 928 008a CF90      		pop r12
 929 008c 0895      		ret
 930               		.cfi_endproc
 931               	.LFE39:
 933               		.section	.text.matrix_key_count,"ax",@progbits
 934               	.global	matrix_key_count
 936               	matrix_key_count:
 937               	.LFB40:
 239:matrix.c      ****     uint8_t count = 0;
 938               		.loc 1 239 0
 939               		.cfi_startproc
 940 0000 1F93      		push r17
 941               	.LCFI33:
 942               		.cfi_def_cfa_offset 3
 943               		.cfi_offset 17, -2
 944 0002 CF93      		push r28
 945               	.LCFI34:
 946               		.cfi_def_cfa_offset 4
 947               		.cfi_offset 28, -3
 948 0004 DF93      		push r29
 949               	.LCFI35:
 950               		.cfi_def_cfa_offset 5
 951               		.cfi_offset 29, -4
 952               	/* prologue: function */
 953               	/* frame size = 0 */
 954               	/* stack size = 3 */
 955               	.L__stack_usage = 3
 956               	.LVL52:
 957 0006 C0E0      		ldi r28,lo8(matrix)
 958 0008 D0E0      		ldi r29,hi8(matrix)
 240:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 959               		.loc 1 240 0
 960 000a 10E0      		ldi r17,0
 961               	.LVL53:
 962               	.L90:
 963               	.LBB72:
 242:matrix.c      ****     }
 964               		.loc 1 242 0 discriminator 2
 965 000c 8991      		ld r24,Y+
 966               	.LVL54:
 967 000e 90E0      		ldi r25,0
 968 0010 0E94 0000 		call bitpop16
 969               	.LVL55:
 970 0014 180F      		add r17,r24
 971               	.LVL56:
 241:matrix.c      ****         count += bitpop16(matrix[i]);
 972               		.loc 1 241 0 discriminator 2
 973 0016 80E0      		ldi r24,hi8(matrix+14)
 974 0018 C030      		cpi r28,lo8(matrix+14)
 975 001a D807      		cpc r29,r24
 976 001c 01F4      		brne .L90
 977               	.LBE72:
 245:matrix.c      **** 
 978               		.loc 1 245 0
 979 001e 812F      		mov r24,r17
 980               	/* epilogue start */
 981 0020 DF91      		pop r29
 982 0022 CF91      		pop r28
 983               	.LVL57:
 984 0024 1F91      		pop r17
 985               	.LVL58:
 986 0026 0895      		ret
 987               		.cfi_endproc
 988               	.LFE40:
 990               		.section	.progmem.data,"a",@progbits
 993               	__c.2489:
 994 0000 0A00      		.string	"\n"
 997               	__c.2487:
 998 0002 2530 3136 		.string	"%016b"
 998      6200 
 1001               	__c.2485:
 1002 0008 3A20 00   		.string	": "
 1005               	__c.2483:
 1006 000b 2530 3258 		.string	"%02X"
 1006      00
 1009               	__c.2480:
 1010 0010 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 1010      2030 3132 
 1010      3334 3536 
 1010      3738 3941 
 1010      4243 4445 
 1013               	__c.2458:
 1014 0027 0A00      		.string	"\n"
 1017               	__c.2456:
 1018 0029 2530 3258 		.string	"%02X"
 1018      00
 1021               	__c.2454:
 1022 002e 626F 756E 		.string	"bounce!: "
 1022      6365 213A 
 1022      2000 
 1025               	__c.2450:
 1026 0038 6C65 6674 		.string	"left side attached\n"
 1026      2073 6964 
 1026      6520 6174 
 1026      7461 6368 
 1026      6564 0A00 
 1029               	__c.2448:
 1030 004c 6C65 6674 		.string	"left side not responding\n"
 1030      2073 6964 
 1030      6520 6E6F 
 1030      7420 7265 
 1030      7370 6F6E 
 1033               	__c.2446:
 1034 0066 7472 7969 		.string	"trying to reset mcp23018\n"
 1034      6E67 2074 
 1034      6F20 7265 
 1034      7365 7420 
 1034      6D63 7032 
 1035               		.local	mcp23018_reset_loop
 1036               		.comm	mcp23018_reset_loop,1,1
 1037               		.local	matrix_debouncing
 1038               		.comm	matrix_debouncing,14,1
 1039               		.local	matrix
 1040               		.comm	matrix,14,1
 1041               		.data
 1044               	debouncing:
 1045 0000 02        		.byte	2
 1046               		.text
 1047               	.Letext0:
 1048               		.file 4 "/usr/lib/avr/include/stdint.h"
 1049               		.file 5 "../../common/debug.h"
 1050               		.file 6 "../../common/matrix.h"
 1051               		.file 7 "ergodox.h"
 1052               		.file 8 "i2cmaster.h"
 1053               		.file 9 "../../common/avr/xprintf.h"
 1054               		.file 10 "../../common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccBquXyW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccBquXyW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccBquXyW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccBquXyW.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccBquXyW.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccBquXyW.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccBquXyW.s:80     .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccBquXyW.s:96     .text.matrix_power_down:0000000000000000 matrix_power_down
     /tmp/ccBquXyW.s:111    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccBquXyW.s:128    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccBquXyW.s:145    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccBquXyW.s:1038   .bss:000000000000000f matrix
     /tmp/ccBquXyW.s:1036   .bss:0000000000000001 matrix_debouncing
     /tmp/ccBquXyW.s:207    .text.matrix_scan:0000000000000000 matrix_scan
                             .bss:0000000000000000 mcp23018_reset_loop
     /tmp/ccBquXyW.s:1033   .progmem.data:0000000000000066 __c.2446
     /tmp/ccBquXyW.s:1029   .progmem.data:000000000000004c __c.2448
     /tmp/ccBquXyW.s:1025   .progmem.data:0000000000000038 __c.2450
     /tmp/ccBquXyW.s:1017   .progmem.data:0000000000000029 __c.2456
     /tmp/ccBquXyW.s:1044   .data:0000000000000000 debouncing
     /tmp/ccBquXyW.s:1021   .progmem.data:000000000000002e __c.2454
     /tmp/ccBquXyW.s:1013   .progmem.data:0000000000000027 __c.2458
     /tmp/ccBquXyW.s:711    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccBquXyW.s:733    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccBquXyW.s:774    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccBquXyW.s:798    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccBquXyW.s:1009   .progmem.data:0000000000000010 __c.2480
     /tmp/ccBquXyW.s:1005   .progmem.data:000000000000000b __c.2483
     /tmp/ccBquXyW.s:997    .progmem.data:0000000000000002 __c.2487
     /tmp/ccBquXyW.s:1001   .progmem.data:0000000000000008 __c.2485
     /tmp/ccBquXyW.s:993    .progmem.data:0000000000000000 __c.2489
     /tmp/ccBquXyW.s:936    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
mcp23018_status
i2c_start
i2c_write
ergodox_left_led_3
i2c_stop
init_ergodox
init_mcp23018
ergodox_blink_all_leds
xputs
debug_config
__xprintf
i2c_readNak
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
