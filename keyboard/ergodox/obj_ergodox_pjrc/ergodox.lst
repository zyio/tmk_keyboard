   1               		.file	"ergodox.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_power_up,"ax",@progbits
  11               		.weak	matrix_power_up
  13               	matrix_power_up:
  14               	.LFB9:
  15               		.file 1 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  16               		.loc 1 65 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE9:
  26               		.section	.text.matrix_power_down,"ax",@progbits
  27               		.weak	matrix_power_down
  29               	matrix_power_down:
  30               	.LFB10:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  31               		.loc 1 66 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0895      		ret
  38               		.cfi_endproc
  39               	.LFE10:
  41               		.section	.text.init_ergodox,"ax",@progbits
  42               	.global	init_ergodox
  44               	init_ergodox:
  45               	.LFB32:
  46               		.file 2 "ergodox.c"
   1:ergodox.c     **** /*
   2:ergodox.c     **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   3:ergodox.c     **** 
   4:ergodox.c     **** This program is free software: you can redistribute it and/or modify
   5:ergodox.c     **** it under the terms of the GNU General Public License as published by
   6:ergodox.c     **** the Free Software Foundation, either version 2 of the License, or
   7:ergodox.c     **** (at your option) any later version.
   8:ergodox.c     **** 
   9:ergodox.c     **** This program is distributed in the hope that it will be useful,
  10:ergodox.c     **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:ergodox.c     **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:ergodox.c     **** GNU General Public License for more details.
  13:ergodox.c     **** 
  14:ergodox.c     **** You should have received a copy of the GNU General Public License
  15:ergodox.c     **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:ergodox.c     **** 
  17:ergodox.c     **** 
  18:ergodox.c     **** This work is heavily based on initial firmware for Ergodox keyboard.
  19:ergodox.c     **** Copyright (c) 2012, 2013 Ben Blazak <benblazak.dev@gmail.com>
  20:ergodox.c     **** Released under The MIT License (see "doc/licenses/MIT.md")
  21:ergodox.c     **** Project located at <https://github.com/benblazak/ergodox-firmware>
  22:ergodox.c     **** 
  23:ergodox.c     **** Most used files are located at
  24:ergodox.c     **** <https://github.com/benblazak/ergodox-firmware/tree/partial-rewrite/firmware/keyboard/ergodox/contr
  25:ergodox.c     **** 
  26:ergodox.c     **** */
  27:ergodox.c     **** 
  28:ergodox.c     **** #include <stdint.h>
  29:ergodox.c     **** #include <stdbool.h>
  30:ergodox.c     **** #include <avr/io.h>
  31:ergodox.c     **** #include <avr/interrupt.h>
  32:ergodox.c     **** #include <util/delay.h>
  33:ergodox.c     **** #include "action.h"
  34:ergodox.c     **** #include "command.h"
  35:ergodox.c     **** #include "print.h"
  36:ergodox.c     **** #include "debug.h"
  37:ergodox.c     **** #include "ergodox.h"
  38:ergodox.c     **** #include "i2cmaster.h"
  39:ergodox.c     **** 
  40:ergodox.c     **** bool i2c_initialized = 0;
  41:ergodox.c     **** uint8_t mcp23018_status = 0x20;
  42:ergodox.c     **** 
  43:ergodox.c     **** bool ergodox_left_led_1 = 0;  // left top
  44:ergodox.c     **** bool ergodox_left_led_2 = 0;  // left middle
  45:ergodox.c     **** bool ergodox_left_led_3 = 0;  // left bottom
  46:ergodox.c     **** 
  47:ergodox.c     **** 
  48:ergodox.c     **** void init_ergodox(void)
  49:ergodox.c     **** {
  47               		.loc 2 49 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  50:ergodox.c     ****     // keyboard LEDs (see "PWM on ports OC1(A|B|C)" in "teensy-2-0.md")
  51:ergodox.c     ****     TCCR1A = 0b10101001;  // set and configure fast PWM
  53               		.loc 2 51 0
  54 0000 89EA      		ldi r24,lo8(-87)
  55 0002 8093 8000 		sts 128,r24
  52:ergodox.c     ****     TCCR1B = 0b00001001;  // set and configure fast PWM
  56               		.loc 2 52 0
  57 0006 89E0      		ldi r24,lo8(9)
  58 0008 8093 8100 		sts 129,r24
  53:ergodox.c     **** 
  54:ergodox.c     ****     // (tied to Vcc for hardware convenience)
  55:ergodox.c     ****     DDRB  &= ~(1<<4);  // set B(4) as input
  59               		.loc 2 55 0
  60 000c 2498      		cbi 0x4,4
  56:ergodox.c     ****     PORTB &= ~(1<<4);  // set B(4) internal pull-up disabled
  61               		.loc 2 56 0
  62 000e 2C98      		cbi 0x5,4
  57:ergodox.c     **** 
  58:ergodox.c     ****     // unused pins - C7, D4, D5, D7, E6
  59:ergodox.c     ****     // set as input with internal pull-ip enabled
  60:ergodox.c     ****     DDRC  &= ~(1<<7);
  63               		.loc 2 60 0
  64 0010 3F98      		cbi 0x7,7
  61:ergodox.c     ****     DDRD  &= ~(1<<7 | 1<<5 | 1<<4);
  65               		.loc 2 61 0
  66 0012 8AB1      		in r24,0xa
  67 0014 8F74      		andi r24,lo8(79)
  68 0016 8AB9      		out 0xa,r24
  62:ergodox.c     ****     DDRE  &= ~(1<<6);
  69               		.loc 2 62 0
  70 0018 6E98      		cbi 0xd,6
  63:ergodox.c     ****     PORTC |=  (1<<7);
  71               		.loc 2 63 0
  72 001a 479A      		sbi 0x8,7
  64:ergodox.c     ****     PORTD |=  (1<<7 | 1<<5 | 1<<4);
  73               		.loc 2 64 0
  74 001c 8BB1      		in r24,0xb
  75 001e 806B      		ori r24,lo8(-80)
  76 0020 8BB9      		out 0xb,r24
  65:ergodox.c     ****     PORTE |=  (1<<6);
  77               		.loc 2 65 0
  78 0022 769A      		sbi 0xe,6
  79 0024 0895      		ret
  80               		.cfi_endproc
  81               	.LFE32:
  83               		.section	.text.ergodox_left_leds_update,"ax",@progbits
  84               	.global	ergodox_left_leds_update
  86               	ergodox_left_leds_update:
  87               	.LFB35:
  66:ergodox.c     **** }
  67:ergodox.c     **** 
  68:ergodox.c     **** void ergodox_blink_all_leds(void)
  69:ergodox.c     **** {
  70:ergodox.c     ****     ergodox_led_all_off();
  71:ergodox.c     ****     ergodox_led_all_set(LED_BRIGHTNESS_HI);
  72:ergodox.c     ****     ergodox_led_all_on();
  73:ergodox.c     ****     _delay_ms(333);
  74:ergodox.c     ****     ergodox_led_all_off();
  75:ergodox.c     **** }
  76:ergodox.c     **** 
  77:ergodox.c     **** uint8_t init_mcp23018(void) {
  78:ergodox.c     ****     mcp23018_status = 0x20;
  79:ergodox.c     **** 
  80:ergodox.c     ****     // I2C subsystem
  81:ergodox.c     ****     if (i2c_initialized == 0) {
  82:ergodox.c     ****         i2c_init();  // on pins D(1,0)
  83:ergodox.c     ****         i2c_initialized++;
  84:ergodox.c     ****         _delay_ms(1000);
  85:ergodox.c     ****     }
  86:ergodox.c     **** 
  87:ergodox.c     ****     // set pin direction
  88:ergodox.c     ****     // - unused  : input  : 1
  89:ergodox.c     ****     // - input   : input  : 1
  90:ergodox.c     ****     // - driving : output : 0
  91:ergodox.c     ****     mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  92:ergodox.c     ****     mcp23018_status = i2c_write(IODIRA);            if (mcp23018_status) goto out;
  93:ergodox.c     ****     mcp23018_status = i2c_write(0b00000000);        if (mcp23018_status) goto out;
  94:ergodox.c     ****     mcp23018_status = i2c_write(0b00111111);        if (mcp23018_status) goto out;
  95:ergodox.c     ****     i2c_stop();
  96:ergodox.c     **** 
  97:ergodox.c     ****     // set pull-up
  98:ergodox.c     ****     // - unused  : on  : 1
  99:ergodox.c     ****     // - input   : on  : 1
 100:ergodox.c     ****     // - driving : off : 0
 101:ergodox.c     ****     mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
 102:ergodox.c     ****     mcp23018_status = i2c_write(GPPUA);             if (mcp23018_status) goto out;
 103:ergodox.c     ****     mcp23018_status = i2c_write(0b00000000);        if (mcp23018_status) goto out;
 104:ergodox.c     ****     mcp23018_status = i2c_write(0b00111111);        if (mcp23018_status) goto out;
 105:ergodox.c     **** 
 106:ergodox.c     **** out:
 107:ergodox.c     ****     i2c_stop();
 108:ergodox.c     **** 
 109:ergodox.c     ****     if (!mcp23018_status) mcp23018_status = ergodox_left_leds_update();
 110:ergodox.c     **** 
 111:ergodox.c     ****     return mcp23018_status;
 112:ergodox.c     **** }
 113:ergodox.c     **** 
 114:ergodox.c     **** uint8_t ergodox_left_leds_update(void) {
  88               		.loc 2 114 0
  89               		.cfi_startproc
  90               	/* prologue: function */
  91               	/* frame size = 0 */
  92               	/* stack size = 0 */
  93               	.L__stack_usage = 0
 115:ergodox.c     ****     if (mcp23018_status) { // if there was an error
  94               		.loc 2 115 0
  95 0000 8091 0000 		lds r24,mcp23018_status
  96 0004 8111      		cpse r24,__zero_reg__
  97 0006 00C0      		rjmp .L5
 116:ergodox.c     ****         return mcp23018_status;
 117:ergodox.c     ****     }
 118:ergodox.c     **** 
 119:ergodox.c     ****     // set logical value (doesn't matter on inputs)
 120:ergodox.c     ****     // - unused  : hi-Z : 1
 121:ergodox.c     ****     // - input   : hi-Z : 1
 122:ergodox.c     ****     // - driving : hi-Z : 1
 123:ergodox.c     ****     mcp23018_status = i2c_start(I2C_ADDR_WRITE);    if (mcp23018_status) goto out;
  98               		.loc 2 123 0
  99 0008 80E4      		ldi r24,lo8(64)
 100 000a 0E94 0000 		call i2c_start
 101               	.LVL0:
 102 000e 8093 0000 		sts mcp23018_status,r24
 103 0012 8111      		cpse r24,__zero_reg__
 104 0014 00C0      		rjmp .L7
 124:ergodox.c     ****     mcp23018_status = i2c_write(OLATA);             if (mcp23018_status) goto out;
 105               		.loc 2 124 0
 106 0016 84E1      		ldi r24,lo8(20)
 107 0018 0E94 0000 		call i2c_write
 108               	.LVL1:
 109 001c 8093 0000 		sts mcp23018_status,r24
 110 0020 8111      		cpse r24,__zero_reg__
 111 0022 00C0      		rjmp .L7
 125:ergodox.c     ****     mcp23018_status = i2c_write(0b11111111
 112               		.loc 2 125 0
 113 0024 8091 0000 		lds r24,ergodox_left_led_3
 114 0028 8795      		ror r24
 115 002a 8827      		clr r24
 116 002c 8795      		ror r24
 117 002e 8095      		com r24
 118 0030 0E94 0000 		call i2c_write
 119               	.LVL2:
 120 0034 8093 0000 		sts mcp23018_status,r24
 126:ergodox.c     ****             & ~(ergodox_left_led_3<<LEFT_LED_3_SHIFT)
 127:ergodox.c     ****           );                                        if (mcp23018_status) goto out;
 121               		.loc 2 127 0
 122 0038 8111      		cpse r24,__zero_reg__
 123 003a 00C0      		rjmp .L7
 128:ergodox.c     ****     mcp23018_status = i2c_write(0b11111111
 124               		.loc 2 128 0
 125 003c 8091 0000 		lds r24,ergodox_left_led_1
 126 0040 8795      		ror r24
 127 0042 8827      		clr r24
 128 0044 8795      		ror r24
 129 0046 9091 0000 		lds r25,ergodox_left_led_2
 130 004a 9295      		swap r25
 131 004c 990F      		lsl r25
 132 004e 990F      		lsl r25
 133 0050 907C      		andi r25,lo8(-64)
 134 0052 892B      		or r24,r25
 135 0054 8095      		com r24
 136 0056 0E94 0000 		call i2c_write
 137               	.LVL3:
 138 005a 8093 0000 		sts mcp23018_status,r24
 139               	.L7:
 129:ergodox.c     ****             & ~(ergodox_left_led_2<<LEFT_LED_2_SHIFT)
 130:ergodox.c     ****             & ~(ergodox_left_led_1<<LEFT_LED_1_SHIFT)
 131:ergodox.c     ****           );                                        if (mcp23018_status) goto out;
 132:ergodox.c     **** 
 133:ergodox.c     **** out:
 134:ergodox.c     ****     i2c_stop();
 140               		.loc 2 134 0
 141 005e 0E94 0000 		call i2c_stop
 142               	.LVL4:
 135:ergodox.c     ****     return mcp23018_status;
 143               		.loc 2 135 0
 144 0062 8091 0000 		lds r24,mcp23018_status
 145               	.L5:
 136:ergodox.c     **** }
 146               		.loc 2 136 0
 147 0066 0895      		ret
 148               		.cfi_endproc
 149               	.LFE35:
 151               		.section	.text.ergodox_blink_all_leds,"ax",@progbits
 152               	.global	ergodox_blink_all_leds
 154               	ergodox_blink_all_leds:
 155               	.LFB33:
  69:ergodox.c     ****     ergodox_led_all_off();
 156               		.loc 2 69 0
 157               		.cfi_startproc
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 0 */
 161               	.L__stack_usage = 0
 162               	.LBB96:
 163               	.LBB97:
 164               	.LBB98:
 165               	.LBB99:
 166               		.file 3 "ergodox.h"
   1:ergodox.h     **** /*
   2:ergodox.h     **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   3:ergodox.h     **** 
   4:ergodox.h     **** This program is free software: you can redistribute it and/or modify
   5:ergodox.h     **** it under the terms of the GNU General Public License as published by
   6:ergodox.h     **** the Free Software Foundation, either version 2 of the License, or
   7:ergodox.h     **** (at your option) any later version.
   8:ergodox.h     **** 
   9:ergodox.h     **** This program is distributed in the hope that it will be useful,
  10:ergodox.h     **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:ergodox.h     **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:ergodox.h     **** GNU General Public License for more details.
  13:ergodox.h     **** 
  14:ergodox.h     **** You should have received a copy of the GNU General Public License
  15:ergodox.h     **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:ergodox.h     **** 
  17:ergodox.h     **** 
  18:ergodox.h     **** Copyright (c) 2012, 2013 Ben Blazak <benblazak.dev@gmail.com>
  19:ergodox.h     **** Released under The MIT License (see "doc/licenses/MIT.md")
  20:ergodox.h     **** Project located at <https://github.com/benblazak/ergodox-firmware>
  21:ergodox.h     **** 
  22:ergodox.h     **** Most used files are located at
  23:ergodox.h     **** <https://github.com/benblazak/ergodox-firmware/tree/partial-rewrite/firmware/keyboard/ergodox/contr
  24:ergodox.h     **** 
  25:ergodox.h     **** */
  26:ergodox.h     **** 
  27:ergodox.h     **** #include <stdint.h>
  28:ergodox.h     **** #include <stdbool.h>
  29:ergodox.h     **** #include <avr/io.h>
  30:ergodox.h     **** #include "i2cmaster.h"
  31:ergodox.h     **** 
  32:ergodox.h     **** #define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))
  33:ergodox.h     **** #define CPU_16MHz       0x00
  34:ergodox.h     **** 
  35:ergodox.h     **** // I2C aliases and register addresses (see "mcp23018.md")
  36:ergodox.h     **** #define I2C_ADDR        0b0100000
  37:ergodox.h     **** #define I2C_ADDR_WRITE  ( (I2C_ADDR<<1) | I2C_WRITE )
  38:ergodox.h     **** #define I2C_ADDR_READ   ( (I2C_ADDR<<1) | I2C_READ  )
  39:ergodox.h     **** #define IODIRA          0x00            // i/o direction register
  40:ergodox.h     **** #define IODIRB          0x01
  41:ergodox.h     **** #define GPPUA           0x0C            // GPIO pull-up resistor register
  42:ergodox.h     **** #define GPPUB           0x0D
  43:ergodox.h     **** #define GPIOA           0x12            // general purpose i/o port register (write modifies OLAT)
  44:ergodox.h     **** #define GPIOB           0x13
  45:ergodox.h     **** #define OLATA           0x14            // output latch register
  46:ergodox.h     **** #define OLATB           0x15
  47:ergodox.h     **** 
  48:ergodox.h     **** extern uint8_t mcp23018_status;
  49:ergodox.h     **** 
  50:ergodox.h     **** void init_ergodox(void);
  51:ergodox.h     **** void ergodox_blink_all_leds(void);
  52:ergodox.h     **** uint8_t init_mcp23018(void);
  53:ergodox.h     **** uint8_t ergodox_left_leds_update(void);
  54:ergodox.h     **** 
  55:ergodox.h     **** #define LED_BRIGHTNESS_LO       31
  56:ergodox.h     **** #define LED_BRIGHTNESS_HI       255
  57:ergodox.h     **** 
  58:ergodox.h     **** #define LEFT_LED_1_SHIFT        7       // in MCP23018 port B
  59:ergodox.h     **** #define LEFT_LED_2_SHIFT        6       // in MCP23018 port B
  60:ergodox.h     **** #define LEFT_LED_3_SHIFT        7       // in MCP23018 port A
  61:ergodox.h     **** 
  62:ergodox.h     **** extern bool ergodox_left_led_1;         // left top
  63:ergodox.h     **** extern bool ergodox_left_led_2;         // left middle
  64:ergodox.h     **** extern bool ergodox_left_led_3;         // left bottom
  65:ergodox.h     **** 
  66:ergodox.h     **** inline void ergodox_board_led_on(void)      { DDRD |=  (1<<6); PORTD |=  (1<<6); }
  67:ergodox.h     **** inline void ergodox_right_led_1_on(void)    { DDRB |=  (1<<5); PORTB |=  (1<<5); }
  68:ergodox.h     **** inline void ergodox_right_led_2_on(void)    { DDRB |=  (1<<6); PORTB |=  (1<<6); }
  69:ergodox.h     **** inline void ergodox_right_led_3_on(void)    { DDRB |=  (1<<7); PORTB |=  (1<<7); }
  70:ergodox.h     **** inline void ergodox_left_led_1_on(void)     { ergodox_left_led_1 = 1; }
  71:ergodox.h     **** inline void ergodox_left_led_2_on(void)     { ergodox_left_led_2 = 1; }
  72:ergodox.h     **** inline void ergodox_left_led_3_on(void)     { ergodox_left_led_3 = 1; }
  73:ergodox.h     **** 
  74:ergodox.h     **** inline void ergodox_board_led_off(void)     { DDRD &= ~(1<<6); PORTD &= ~(1<<6); }
 167               		.loc 3 74 0
 168 0000 5698      		cbi 0xa,6
 169 0002 5E98      		cbi 0xb,6
 170               	.LBE99:
 171               	.LBE98:
 172               	.LBB100:
 173               	.LBB101:
  75:ergodox.h     **** inline void ergodox_right_led_1_off(void)   { DDRB &= ~(1<<5); PORTB &= ~(1<<5); }
 174               		.loc 3 75 0
 175 0004 2598      		cbi 0x4,5
 176 0006 2D98      		cbi 0x5,5
 177               	.LBE101:
 178               	.LBE100:
 179               	.LBB102:
 180               	.LBB103:
  76:ergodox.h     **** inline void ergodox_right_led_2_off(void)   { DDRB &= ~(1<<6); PORTB &= ~(1<<6); }
 181               		.loc 3 76 0
 182 0008 2698      		cbi 0x4,6
 183 000a 2E98      		cbi 0x5,6
 184               	.LBE103:
 185               	.LBE102:
 186               	.LBB104:
 187               	.LBB105:
  77:ergodox.h     **** inline void ergodox_right_led_3_off(void)   { DDRB &= ~(1<<7); PORTB &= ~(1<<7); }
 188               		.loc 3 77 0
 189 000c 2798      		cbi 0x4,7
 190 000e 2F98      		cbi 0x5,7
 191               	.LBE105:
 192               	.LBE104:
 193               	.LBB106:
 194               	.LBB107:
  78:ergodox.h     **** inline void ergodox_left_led_1_off(void)    { ergodox_left_led_1 = 0; }
 195               		.loc 3 78 0
 196 0010 1092 0000 		sts ergodox_left_led_1,__zero_reg__
 197               	.LBE107:
 198               	.LBE106:
 199               	.LBB108:
 200               	.LBB109:
  79:ergodox.h     **** inline void ergodox_left_led_2_off(void)    { ergodox_left_led_2 = 0; }
 201               		.loc 3 79 0
 202 0014 1092 0000 		sts ergodox_left_led_2,__zero_reg__
 203               	.LBE109:
 204               	.LBE108:
 205               	.LBB110:
 206               	.LBB111:
  80:ergodox.h     **** inline void ergodox_left_led_3_off(void)    { ergodox_left_led_3 = 0; }
 207               		.loc 3 80 0
 208 0018 1092 0000 		sts ergodox_left_led_3,__zero_reg__
 209               	.LBE111:
 210               	.LBE110:
  81:ergodox.h     **** 
  82:ergodox.h     **** inline void ergodox_led_all_on(void)
  83:ergodox.h     **** {
  84:ergodox.h     ****     ergodox_board_led_on();
  85:ergodox.h     ****     ergodox_right_led_1_on();
  86:ergodox.h     ****     ergodox_right_led_2_on();
  87:ergodox.h     ****     ergodox_right_led_3_on();
  88:ergodox.h     ****     ergodox_left_led_1_on();
  89:ergodox.h     ****     ergodox_left_led_2_on();
  90:ergodox.h     ****     ergodox_left_led_3_on();
  91:ergodox.h     ****     ergodox_left_leds_update();
  92:ergodox.h     **** }
  93:ergodox.h     **** 
  94:ergodox.h     **** inline void ergodox_led_all_off(void)
  95:ergodox.h     **** {
  96:ergodox.h     ****     ergodox_board_led_off();
  97:ergodox.h     ****     ergodox_right_led_1_off();
  98:ergodox.h     ****     ergodox_right_led_2_off();
  99:ergodox.h     ****     ergodox_right_led_3_off();
 100:ergodox.h     ****     ergodox_left_led_1_off();
 101:ergodox.h     ****     ergodox_left_led_2_off();
 102:ergodox.h     ****     ergodox_left_led_3_off();
 103:ergodox.h     ****     ergodox_left_leds_update();
 211               		.loc 3 103 0
 212 001c 0E94 0000 		call ergodox_left_leds_update
 213               	.LVL5:
 214               	.LBE97:
 215               	.LBE96:
 216               	.LBB112:
 217               	.LBB113:
 218               	.LBB114:
 104:ergodox.h     **** }
 105:ergodox.h     **** 
 106:ergodox.h     **** inline void ergodox_right_led_1_set(uint8_t n)    { OCR1A = n; }
 219               		.loc 3 106 0
 220 0020 8FEF      		ldi r24,lo8(-1)
 221 0022 90E0      		ldi r25,0
 222 0024 9093 8900 		sts 136+1,r25
 223 0028 8093 8800 		sts 136,r24
 224               	.LVL6:
 225               	.LBE114:
 226               	.LBE113:
 227               	.LBB115:
 228               	.LBB116:
 107:ergodox.h     **** inline void ergodox_right_led_2_set(uint8_t n)    { OCR1B = n; }
 229               		.loc 3 107 0
 230 002c 9093 8B00 		sts 138+1,r25
 231 0030 8093 8A00 		sts 138,r24
 232               	.LVL7:
 233               	.LBE116:
 234               	.LBE115:
 235               	.LBB117:
 236               	.LBB118:
 108:ergodox.h     **** inline void ergodox_right_led_3_set(uint8_t n)    { OCR1C = n; }
 237               		.loc 3 108 0
 238 0034 9093 8D00 		sts 140+1,r25
 239 0038 8093 8C00 		sts 140,r24
 240               	.LBE118:
 241               	.LBE117:
 242               	.LBE112:
 243               	.LBB119:
 244               	.LBB120:
 245               	.LBB121:
 246               	.LBB122:
  66:ergodox.h     **** inline void ergodox_right_led_1_on(void)    { DDRB |=  (1<<5); PORTB |=  (1<<5); }
 247               		.loc 3 66 0
 248 003c 569A      		sbi 0xa,6
 249 003e 5E9A      		sbi 0xb,6
 250               	.LBE122:
 251               	.LBE121:
 252               	.LBB123:
 253               	.LBB124:
  67:ergodox.h     **** inline void ergodox_right_led_2_on(void)    { DDRB |=  (1<<6); PORTB |=  (1<<6); }
 254               		.loc 3 67 0
 255 0040 259A      		sbi 0x4,5
 256 0042 2D9A      		sbi 0x5,5
 257               	.LBE124:
 258               	.LBE123:
 259               	.LBB125:
 260               	.LBB126:
  68:ergodox.h     **** inline void ergodox_right_led_3_on(void)    { DDRB |=  (1<<7); PORTB |=  (1<<7); }
 261               		.loc 3 68 0
 262 0044 269A      		sbi 0x4,6
 263 0046 2E9A      		sbi 0x5,6
 264               	.LBE126:
 265               	.LBE125:
 266               	.LBB127:
 267               	.LBB128:
  69:ergodox.h     **** inline void ergodox_left_led_1_on(void)     { ergodox_left_led_1 = 1; }
 268               		.loc 3 69 0
 269 0048 279A      		sbi 0x4,7
 270 004a 2F9A      		sbi 0x5,7
 271               	.LBE128:
 272               	.LBE127:
 273               	.LBB129:
 274               	.LBB130:
  70:ergodox.h     **** inline void ergodox_left_led_2_on(void)     { ergodox_left_led_2 = 1; }
 275               		.loc 3 70 0
 276 004c 81E0      		ldi r24,lo8(1)
 277 004e 8093 0000 		sts ergodox_left_led_1,r24
 278               	.LBE130:
 279               	.LBE129:
 280               	.LBB131:
 281               	.LBB132:
  71:ergodox.h     **** inline void ergodox_left_led_3_on(void)     { ergodox_left_led_3 = 1; }
 282               		.loc 3 71 0
 283 0052 8093 0000 		sts ergodox_left_led_2,r24
 284               	.LBE132:
 285               	.LBE131:
 286               	.LBB133:
 287               	.LBB134:
  72:ergodox.h     **** 
 288               		.loc 3 72 0
 289 0056 8093 0000 		sts ergodox_left_led_3,r24
 290               	.LBE134:
 291               	.LBE133:
  91:ergodox.h     **** }
 292               		.loc 3 91 0
 293 005a 0E94 0000 		call ergodox_left_leds_update
 294               	.LVL8:
 295               	.LBE120:
 296               	.LBE119:
 297               	.LBB135:
 298               	.LBB136:
 299               		.file 4 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 300               		.loc 4 163 0
 301 005e 2FE7      		ldi r18,lo8(1065599)
 302 0060 82E4      		ldi r24,hi8(1065599)
 303 0062 90E1      		ldi r25,hlo8(1065599)
 304 0064 2150      		1: subi r18,1
 305 0066 8040      		sbci r24,0
 306 0068 9040      		sbci r25,0
 307 006a 01F4      		brne 1b
 308 006c 00C0      		rjmp .
 309 006e 0000      		nop
 310               	.LBE136:
 311               	.LBE135:
 312               	.LBB137:
 313               	.LBB138:
 314               	.LBB139:
 315               	.LBB140:
  74:ergodox.h     **** inline void ergodox_right_led_1_off(void)   { DDRB &= ~(1<<5); PORTB &= ~(1<<5); }
 316               		.loc 3 74 0
 317 0070 5698      		cbi 0xa,6
 318 0072 5E98      		cbi 0xb,6
 319               	.LBE140:
 320               	.LBE139:
 321               	.LBB141:
 322               	.LBB142:
  75:ergodox.h     **** inline void ergodox_right_led_2_off(void)   { DDRB &= ~(1<<6); PORTB &= ~(1<<6); }
 323               		.loc 3 75 0
 324 0074 2598      		cbi 0x4,5
 325 0076 2D98      		cbi 0x5,5
 326               	.LBE142:
 327               	.LBE141:
 328               	.LBB143:
 329               	.LBB144:
  76:ergodox.h     **** inline void ergodox_right_led_3_off(void)   { DDRB &= ~(1<<7); PORTB &= ~(1<<7); }
 330               		.loc 3 76 0
 331 0078 2698      		cbi 0x4,6
 332 007a 2E98      		cbi 0x5,6
 333               	.LBE144:
 334               	.LBE143:
 335               	.LBB145:
 336               	.LBB146:
  77:ergodox.h     **** inline void ergodox_left_led_1_off(void)    { ergodox_left_led_1 = 0; }
 337               		.loc 3 77 0
 338 007c 2798      		cbi 0x4,7
 339 007e 2F98      		cbi 0x5,7
 340               	.LBE146:
 341               	.LBE145:
 342               	.LBB147:
 343               	.LBB148:
  78:ergodox.h     **** inline void ergodox_left_led_2_off(void)    { ergodox_left_led_2 = 0; }
 344               		.loc 3 78 0
 345 0080 1092 0000 		sts ergodox_left_led_1,__zero_reg__
 346               	.LBE148:
 347               	.LBE147:
 348               	.LBB149:
 349               	.LBB150:
  79:ergodox.h     **** inline void ergodox_left_led_3_off(void)    { ergodox_left_led_3 = 0; }
 350               		.loc 3 79 0
 351 0084 1092 0000 		sts ergodox_left_led_2,__zero_reg__
 352               	.LBE150:
 353               	.LBE149:
 354               	.LBB151:
 355               	.LBB152:
  80:ergodox.h     **** 
 356               		.loc 3 80 0
 357 0088 1092 0000 		sts ergodox_left_led_3,__zero_reg__
 358               	.LBE152:
 359               	.LBE151:
 103:ergodox.h     **** }
 360               		.loc 3 103 0
 361 008c 0C94 0000 		jmp ergodox_left_leds_update
 362               	.LVL9:
 363               	.LBE138:
 364               	.LBE137:
 365               		.cfi_endproc
 366               	.LFE33:
 368               		.section	.text.init_mcp23018,"ax",@progbits
 369               	.global	init_mcp23018
 371               	init_mcp23018:
 372               	.LFB34:
  77:ergodox.c     ****     mcp23018_status = 0x20;
 373               		.loc 2 77 0
 374               		.cfi_startproc
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 0 */
 378               	.L__stack_usage = 0
  78:ergodox.c     **** 
 379               		.loc 2 78 0
 380 0000 80E2      		ldi r24,lo8(32)
 381 0002 8093 0000 		sts mcp23018_status,r24
  81:ergodox.c     ****         i2c_init();  // on pins D(1,0)
 382               		.loc 2 81 0
 383 0006 8091 0000 		lds r24,i2c_initialized
 384 000a 8111      		cpse r24,__zero_reg__
 385 000c 00C0      		rjmp .L13
  82:ergodox.c     ****         i2c_initialized++;
 386               		.loc 2 82 0
 387 000e 0E94 0000 		call i2c_init
 388               	.LVL10:
  83:ergodox.c     ****         _delay_ms(1000);
 389               		.loc 2 83 0
 390 0012 81E0      		ldi r24,lo8(1)
 391 0014 8093 0000 		sts i2c_initialized,r24
 392               	.LVL11:
 393               	.LBB153:
 394               	.LBB154:
 395               		.loc 4 163 0
 396 0018 2FEF      		ldi r18,lo8(3199999)
 397 001a 83ED      		ldi r24,hi8(3199999)
 398 001c 90E3      		ldi r25,hlo8(3199999)
 399 001e 2150      		1: subi r18,1
 400 0020 8040      		sbci r24,0
 401 0022 9040      		sbci r25,0
 402 0024 01F4      		brne 1b
 403 0026 00C0      		rjmp .
 404 0028 0000      		nop
 405               	.LVL12:
 406               	.L13:
 407               	.LBE154:
 408               	.LBE153:
  91:ergodox.c     ****     mcp23018_status = i2c_write(IODIRA);            if (mcp23018_status) goto out;
 409               		.loc 2 91 0
 410 002a 80E4      		ldi r24,lo8(64)
 411 002c 0E94 0000 		call i2c_start
 412               	.LVL13:
 413 0030 8093 0000 		sts mcp23018_status,r24
 414 0034 8111      		cpse r24,__zero_reg__
 415 0036 00C0      		rjmp .L15
  92:ergodox.c     ****     mcp23018_status = i2c_write(0b00000000);        if (mcp23018_status) goto out;
 416               		.loc 2 92 0
 417 0038 0E94 0000 		call i2c_write
 418               	.LVL14:
 419 003c 8093 0000 		sts mcp23018_status,r24
 420 0040 8111      		cpse r24,__zero_reg__
 421 0042 00C0      		rjmp .L15
  93:ergodox.c     ****     mcp23018_status = i2c_write(0b00111111);        if (mcp23018_status) goto out;
 422               		.loc 2 93 0
 423 0044 0E94 0000 		call i2c_write
 424               	.LVL15:
 425 0048 8093 0000 		sts mcp23018_status,r24
 426 004c 8111      		cpse r24,__zero_reg__
 427 004e 00C0      		rjmp .L15
  94:ergodox.c     ****     i2c_stop();
 428               		.loc 2 94 0
 429 0050 8FE3      		ldi r24,lo8(63)
 430 0052 0E94 0000 		call i2c_write
 431               	.LVL16:
 432 0056 8093 0000 		sts mcp23018_status,r24
 433 005a 8111      		cpse r24,__zero_reg__
 434 005c 00C0      		rjmp .L15
  95:ergodox.c     **** 
 435               		.loc 2 95 0
 436 005e 0E94 0000 		call i2c_stop
 437               	.LVL17:
 101:ergodox.c     ****     mcp23018_status = i2c_write(GPPUA);             if (mcp23018_status) goto out;
 438               		.loc 2 101 0
 439 0062 80E4      		ldi r24,lo8(64)
 440 0064 0E94 0000 		call i2c_start
 441               	.LVL18:
 442 0068 8093 0000 		sts mcp23018_status,r24
 443 006c 8111      		cpse r24,__zero_reg__
 444 006e 00C0      		rjmp .L15
 102:ergodox.c     ****     mcp23018_status = i2c_write(0b00000000);        if (mcp23018_status) goto out;
 445               		.loc 2 102 0
 446 0070 8CE0      		ldi r24,lo8(12)
 447 0072 0E94 0000 		call i2c_write
 448               	.LVL19:
 449 0076 8093 0000 		sts mcp23018_status,r24
 450 007a 8111      		cpse r24,__zero_reg__
 451 007c 00C0      		rjmp .L15
 103:ergodox.c     ****     mcp23018_status = i2c_write(0b00111111);        if (mcp23018_status) goto out;
 452               		.loc 2 103 0
 453 007e 0E94 0000 		call i2c_write
 454               	.LVL20:
 455 0082 8093 0000 		sts mcp23018_status,r24
 456 0086 8111      		cpse r24,__zero_reg__
 457 0088 00C0      		rjmp .L15
 104:ergodox.c     **** 
 458               		.loc 2 104 0
 459 008a 8FE3      		ldi r24,lo8(63)
 460 008c 0E94 0000 		call i2c_write
 461               	.LVL21:
 462 0090 8093 0000 		sts mcp23018_status,r24
 463               	.L15:
 107:ergodox.c     **** 
 464               		.loc 2 107 0
 465 0094 0E94 0000 		call i2c_stop
 466               	.LVL22:
 109:ergodox.c     **** 
 467               		.loc 2 109 0
 468 0098 8091 0000 		lds r24,mcp23018_status
 469 009c 8111      		cpse r24,__zero_reg__
 470 009e 00C0      		rjmp .L17
 109:ergodox.c     **** 
 471               		.loc 2 109 0 is_stmt 0 discriminator 1
 472 00a0 0E94 0000 		call ergodox_left_leds_update
 473               	.LVL23:
 474 00a4 8093 0000 		sts mcp23018_status,r24
 475               	.L17:
 112:ergodox.c     **** 
 476               		.loc 2 112 0 is_stmt 1
 477 00a8 8091 0000 		lds r24,mcp23018_status
 478 00ac 0895      		ret
 479               		.cfi_endproc
 480               	.LFE34:
 482               	.global	ergodox_left_led_3
 483               		.section .bss
 486               	ergodox_left_led_3:
 487 0000 00        		.zero	1
 488               	.global	ergodox_left_led_2
 491               	ergodox_left_led_2:
 492 0001 00        		.zero	1
 493               	.global	ergodox_left_led_1
 496               	ergodox_left_led_1:
 497 0002 00        		.zero	1
 498               	.global	mcp23018_status
 499               		.data
 502               	mcp23018_status:
 503 0000 20        		.byte	32
 504               	.global	i2c_initialized
 505               		.section .bss
 508               	i2c_initialized:
 509 0003 00        		.zero	1
 510               		.text
 511               	.Letext0:
 512               		.file 5 "/usr/lib/avr/include/stdint.h"
 513               		.file 6 "i2cmaster.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ergodox.c
     /tmp/cc8ZppwR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8ZppwR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8ZppwR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8ZppwR.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8ZppwR.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8ZppwR.s:13     .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/cc8ZppwR.s:29     .text.matrix_power_down:0000000000000000 matrix_power_down
     /tmp/cc8ZppwR.s:44     .text.init_ergodox:0000000000000000 init_ergodox
     /tmp/cc8ZppwR.s:86     .text.ergodox_left_leds_update:0000000000000000 ergodox_left_leds_update
     /tmp/cc8ZppwR.s:502    .data:0000000000000000 mcp23018_status
     /tmp/cc8ZppwR.s:486    .bss:0000000000000000 ergodox_left_led_3
     /tmp/cc8ZppwR.s:496    .bss:0000000000000002 ergodox_left_led_1
     /tmp/cc8ZppwR.s:491    .bss:0000000000000001 ergodox_left_led_2
     /tmp/cc8ZppwR.s:154    .text.ergodox_blink_all_leds:0000000000000000 ergodox_blink_all_leds
     /tmp/cc8ZppwR.s:371    .text.init_mcp23018:0000000000000000 init_mcp23018
     /tmp/cc8ZppwR.s:508    .bss:0000000000000003 i2c_initialized

UNDEFINED SYMBOLS
i2c_start
i2c_write
i2c_stop
i2c_init
__do_copy_data
__do_clear_bss
