   1               		.file	"keymap.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_power_up,"ax",@progbits
  11               		.weak	matrix_power_up
  13               	matrix_power_up:
  14               	.LFB10:
  15               		.file 1 "../../common/keyboard.h"
   1:../../common/keyboard.h **** /*
   2:../../common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../common/keyboard.h **** 
   4:../../common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../common/keyboard.h **** (at your option) any later version.
   8:../../common/keyboard.h **** 
   9:../../common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../common/keyboard.h **** GNU General Public License for more details.
  13:../../common/keyboard.h **** 
  14:../../common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../common/keyboard.h **** */
  17:../../common/keyboard.h **** 
  18:../../common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../common/keyboard.h **** #define KEYBOARD_H
  20:../../common/keyboard.h **** 
  21:../../common/keyboard.h **** #include <stdbool.h>
  22:../../common/keyboard.h **** #include <stdint.h>
  23:../../common/keyboard.h **** 
  24:../../common/keyboard.h **** 
  25:../../common/keyboard.h **** #ifdef __cplusplus
  26:../../common/keyboard.h **** extern "C" {
  27:../../common/keyboard.h **** #endif
  28:../../common/keyboard.h **** 
  29:../../common/keyboard.h **** /* key matrix position */
  30:../../common/keyboard.h **** typedef struct {
  31:../../common/keyboard.h ****     uint8_t col;
  32:../../common/keyboard.h ****     uint8_t row;
  33:../../common/keyboard.h **** } keypos_t;
  34:../../common/keyboard.h **** 
  35:../../common/keyboard.h **** /* key event */
  36:../../common/keyboard.h **** typedef struct {
  37:../../common/keyboard.h ****     keypos_t key;
  38:../../common/keyboard.h ****     bool     pressed;
  39:../../common/keyboard.h ****     uint16_t time;
  40:../../common/keyboard.h **** } keyevent_t;
  41:../../common/keyboard.h **** 
  42:../../common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../common/keyboard.h **** 
  45:../../common/keyboard.h **** /* Rules for No Event:
  46:../../common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../common/keyboard.h ****  */
  49:../../common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  50:../../common/keyboard.h **** static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
  51:../../common/keyboard.h **** static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
  52:../../common/keyboard.h **** 
  53:../../common/keyboard.h **** /* Tick event */
  54:../../common/keyboard.h **** #define TICK                    (keyevent_t){           \
  55:../../common/keyboard.h ****     .key = (keypos_t){ .row = 255, .col = 255 },           \
  56:../../common/keyboard.h ****     .pressed = false,                                   \
  57:../../common/keyboard.h ****     .time = (timer_read() | 1)                          \
  58:../../common/keyboard.h **** }
  59:../../common/keyboard.h **** 
  60:../../common/keyboard.h **** 
  61:../../common/keyboard.h **** void keyboard_init(void);
  62:../../common/keyboard.h **** void keyboard_task(void);
  63:../../common/keyboard.h **** void keyboard_set_leds(uint8_t leds);
  64:../../common/keyboard.h **** 
  65:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_up(void) {}
  16               		.loc 1 65 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE10:
  26               		.section	.text.matrix_power_down,"ax",@progbits
  27               		.weak	matrix_power_down
  29               	matrix_power_down:
  30               	.LFB11:
  66:../../common/keyboard.h **** __attribute__ ((weak)) void matrix_power_down(void) {}
  31               		.loc 1 66 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0895      		ret
  38               		.cfi_endproc
  39               	.LFE11:
  41               		.section	.text.action_function,"ax",@progbits
  42               	.global	action_function
  44               	action_function:
  45               	.LFB32:
  46               		.file 2 "keymap.c"
   1:keymap.c      **** /*
   2:keymap.c      **** Copyright 2013 Oleg Kostyuk <cub.uanic@gmail.com>
   3:keymap.c      **** 
   4:keymap.c      **** This program is free software: you can redistribute it and/or modify
   5:keymap.c      **** it under the terms of the GNU General Public License as published by
   6:keymap.c      **** the Free Software Foundation, either version 2 of the License, or
   7:keymap.c      **** (at your option) any later version.
   8:keymap.c      **** 
   9:keymap.c      **** This program is distributed in the hope that it will be useful,
  10:keymap.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:keymap.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:keymap.c      **** GNU General Public License for more details.
  13:keymap.c      **** 
  14:keymap.c      **** You should have received a copy of the GNU General Public License
  15:keymap.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:keymap.c      **** */
  17:keymap.c      **** #include <stdint.h>
  18:keymap.c      **** #include <stdbool.h>
  19:keymap.c      **** #include <avr/pgmspace.h>
  20:keymap.c      **** #include <util/delay.h>
  21:keymap.c      **** #include "keycode.h"
  22:keymap.c      **** #include "action.h"
  23:keymap.c      **** #include "action_util.h"
  24:keymap.c      **** #include "action_code.h"
  25:keymap.c      **** #include "action_macro.h"
  26:keymap.c      **** #include "action_layer.h"
  27:keymap.c      **** #include "bootloader.h"
  28:keymap.c      **** #include "report.h"
  29:keymap.c      **** #include "host.h"
  30:keymap.c      **** #include "print.h"
  31:keymap.c      **** #include "debug.h"
  32:keymap.c      **** #include "keymap.h"
  33:keymap.c      **** #include "ergodox.h"
  34:keymap.c      **** 
  35:keymap.c      **** 
  36:keymap.c      **** /* ErgoDox keymap definition macro */
  37:keymap.c      **** #define KEYMAP(                                                 \
  38:keymap.c      ****                                                                 \
  39:keymap.c      ****     /* left hand, spatial positions */                          \
  40:keymap.c      ****     k00,k01,k02,k03,k04,k05,k06,                                \
  41:keymap.c      ****     k10,k11,k12,k13,k14,k15,k16,                                \
  42:keymap.c      ****     k20,k21,k22,k23,k24,k25,                                    \
  43:keymap.c      ****     k30,k31,k32,k33,k34,k35,k36,                                \
  44:keymap.c      ****     k40,k41,k42,k43,k44,                                        \
  45:keymap.c      ****                             k55,k56,                            \
  46:keymap.c      ****                                 k54,                            \
  47:keymap.c      ****                         k53,k52,k51,                            \
  48:keymap.c      ****                                                                 \
  49:keymap.c      ****     /* right hand, spatial positions */                         \
  50:keymap.c      ****         k07,k08,k09,k0A,k0B,k0C,k0D,                            \
  51:keymap.c      ****         k17,k18,k19,k1A,k1B,k1C,k1D,                            \
  52:keymap.c      ****             k28,k29,k2A,k2B,k2C,k2D,                            \
  53:keymap.c      ****         k37,k38,k39,k3A,k3B,k3C,k3D,                            \
  54:keymap.c      ****                 k49,k4A,k4B,k4C,k4D,                            \
  55:keymap.c      ****     k57,k58,                                                    \
  56:keymap.c      ****     k59,                                                        \
  57:keymap.c      ****     k5C,k5B,k5A )                                               \
  58:keymap.c      ****                                                                 \
  59:keymap.c      ****    /* matrix positions */                                       \
  60:keymap.c      ****    {                                                            \
  61:keymap.c      ****     { KC_##k00,KC_##k10,KC_##k20,KC_##k30,KC_##k40,KC_NO   },   \
  62:keymap.c      ****     { KC_##k01,KC_##k11,KC_##k21,KC_##k31,KC_##k41,KC_##k51},   \
  63:keymap.c      ****     { KC_##k02,KC_##k12,KC_##k22,KC_##k32,KC_##k42,KC_##k52},   \
  64:keymap.c      ****     { KC_##k03,KC_##k13,KC_##k23,KC_##k33,KC_##k43,KC_##k53},   \
  65:keymap.c      ****     { KC_##k04,KC_##k14,KC_##k24,KC_##k34,KC_##k44,KC_##k54},   \
  66:keymap.c      ****     { KC_##k05,KC_##k15,KC_##k25,KC_##k35,KC_NO,   KC_##k55},   \
  67:keymap.c      ****     { KC_##k06,KC_##k16,KC_NO,   KC_##k36,KC_NO,   KC_##k56},   \
  68:keymap.c      ****                                                                 \
  69:keymap.c      ****     { KC_##k07,KC_##k17,KC_NO,   KC_##k37,KC_NO,   KC_##k57},   \
  70:keymap.c      ****     { KC_##k08,KC_##k18,KC_##k28,KC_##k38,KC_NO,   KC_##k58},   \
  71:keymap.c      ****     { KC_##k09,KC_##k19,KC_##k29,KC_##k39,KC_##k49,KC_##k59},   \
  72:keymap.c      ****     { KC_##k0A,KC_##k1A,KC_##k2A,KC_##k3A,KC_##k4A,KC_##k5A},   \
  73:keymap.c      ****     { KC_##k0B,KC_##k1B,KC_##k2B,KC_##k3B,KC_##k4B,KC_##k5B},   \
  74:keymap.c      ****     { KC_##k0C,KC_##k1C,KC_##k2C,KC_##k3C,KC_##k4C,KC_##k5C},   \
  75:keymap.c      ****     { KC_##k0D,KC_##k1D,KC_##k2D,KC_##k3D,KC_##k4D,KC_NO   }    \
  76:keymap.c      ****    }
  77:keymap.c      **** 
  78:keymap.c      **** #if defined(KEYMAP_DVORAK)
  79:keymap.c      **** #include "keymap_dvorak.h"
  80:keymap.c      **** #elif defined(KEYMAP_COLEMAK)
  81:keymap.c      **** #include "keymap_colemak.h"
  82:keymap.c      **** #elif defined(KEYMAP_WORKMAN)
  83:keymap.c      **** #include "keymap_workman.h"
  84:keymap.c      **** #elif defined(KEYMAP_MICRO)
  85:keymap.c      **** #include "keymap_micro.h"
  86:keymap.c      **** #elif defined(KEYMAP_CUB)
  87:keymap.c      **** #include "keymap_cub.h"
  88:keymap.c      **** #elif defined(KEYMAP_PLOVER)
  89:keymap.c      **** #include "keymap_plover.h"
  90:keymap.c      **** #elif defined(KEYMAP_SIMON)
  91:keymap.c      **** #include "keymap_simon.h"
  92:keymap.c      **** #else
  93:keymap.c      **** 
  94:keymap.c      **** static const uint8_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
  95:keymap.c      ****   KEYMAP(  // layer 0 : default
  96:keymap.c      ****       // left hand
  97:keymap.c      ****       ESC, 1,   2,   3,   4,   5,   MINS,
  98:keymap.c      ****       TAB,Q,   W,   E,   R,   T,   LBRC,
  99:keymap.c      ****       LCTL, A,   S,   D,   F,   G,
 100:keymap.c      ****       LSFT,Z,   X,   C,   V,   B,   FN1,
 101:keymap.c      ****       LGUI,GRV, NUHS,QUOT,BSLS,
 102:keymap.c      ****                                     LCTL,LALT,
 103:keymap.c      ****                                          HOME,
 104:keymap.c      ****                                SPC,BSPC, END,
 105:keymap.c      ****       // right hand
 106:keymap.c      ****            EQL, 6,   7,   8,   9,   0,   DEL,
 107:keymap.c      ****            RBRC,Y,   U,   I,   O,   P,   NUBS,
 108:keymap.c      ****                 H,   J,   K,   L,   SCLN,QUOT,
 109:keymap.c      ****            FN1, N,   M,   COMM,DOT, SLSH,RSFT,
 110:keymap.c      ****                      LEFT,DOWN,UP,  RGHT,RGUI,
 111:keymap.c      ****       PSCR,INS,
 112:keymap.c      ****       PGUP,
 113:keymap.c      ****       PGDN,ENT, SPC
 114:keymap.c      ****   ),
 115:keymap.c      **** 
 116:keymap.c      ****     KEYMAP(  // layer 1 : function and symbol keys
 117:keymap.c      ****         // left hand
 118:keymap.c      ****         TRNS,F1,  F2,  F3,  F4,  F5,  F11,
 119:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,FN4,
 120:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 121:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 122:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,
 123:keymap.c      ****                                       TRNS,TRNS,
 124:keymap.c      ****                                            TRNS,
 125:keymap.c      ****                                  TRNS,TRNS,TRNS,
 126:keymap.c      ****         // right hand
 127:keymap.c      ****              F12, F6,  F7,  F8,  F9,  F10, TRNS,
 128:keymap.c      ****              TRNS,TRNS,TRNS,P7,P8,P9,PSLS,
 129:keymap.c      ****                   TRNS,TRNS,P4,P5,P6,PAST,
 130:keymap.c      ****              TRNS,TRNS,TRNS,P1,P2,P3,PMNS,
 131:keymap.c      ****                        TRNS,P0,P0,PDOT,PEQL,
 132:keymap.c      ****         TRNS,TRNS,
 133:keymap.c      ****         TRNS,
 134:keymap.c      ****         TRNS,TRNS,TRNS
 135:keymap.c      ****     ),
 136:keymap.c      **** 
 137:keymap.c      ****     KEYMAP(  // layer 2 : keyboard functions
 138:keymap.c      ****         // left hand
 139:keymap.c      ****         FN0, TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 140:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 141:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 142:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 143:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,
 144:keymap.c      ****                                       TRNS,TRNS,
 145:keymap.c      ****                                            TRNS,
 146:keymap.c      ****                                  TRNS,TRNS,TRNS,
 147:keymap.c      ****         // right hand
 148:keymap.c      ****              FN4, TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 149:keymap.c      ****              TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 150:keymap.c      ****                   TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 151:keymap.c      ****              TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 152:keymap.c      ****                        TRNS,TRNS,TRNS,TRNS,TRNS,
 153:keymap.c      ****         TRNS,TRNS,
 154:keymap.c      ****         TRNS,
 155:keymap.c      ****         TRNS,TRNS,TRNS
 156:keymap.c      ****     ),
 157:keymap.c      **** 
 158:keymap.c      ****     KEYMAP(  // layer 3: numpad
 159:keymap.c      ****         // left hand
 160:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 161:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 162:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 163:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
 164:keymap.c      ****         TRNS,TRNS,TRNS,TRNS,TRNS,
 165:keymap.c      ****                                       TRNS,TRNS,
 166:keymap.c      ****                                            TRNS,
 167:keymap.c      ****                                  TRNS,TRNS,TRNS,
 168:keymap.c      ****         // right hand
 169:keymap.c      ****              TRNS,NLCK,PSLS,PAST,PAST,PMNS,BSPC,
 170:keymap.c      ****              TRNS,NO,  P7,  P8,  P9,  PMNS,BSPC,
 171:keymap.c      ****                   NO,  P4,  P5,  P6,  PPLS,PENT,
 172:keymap.c      ****              TRNS,NO,  P1,  P2,  P3,  PPLS,PENT,
 173:keymap.c      ****                        P0,  PDOT,SLSH,PENT,PENT,
 174:keymap.c      ****         TRNS,TRNS,
 175:keymap.c      ****         TRNS,
 176:keymap.c      ****         TRNS,TRNS,TRNS
 177:keymap.c      ****     ),
 178:keymap.c      **** 
 179:keymap.c      **** };
 180:keymap.c      **** 
 181:keymap.c      **** /* id for user defined functions */
 182:keymap.c      **** enum function_id {
 183:keymap.c      ****     TEENSY_KEY,
 184:keymap.c      **** };
 185:keymap.c      **** 
 186:keymap.c      **** /*
 187:keymap.c      ****  * Fn action definition
 188:keymap.c      ****  */
 189:keymap.c      **** static const uint16_t PROGMEM fn_actions[] = {
 190:keymap.c      ****     ACTION_FUNCTION(TEENSY_KEY),                    // FN0 - Teensy key
 191:keymap.c      ****     ACTION_LAYER_MOMENTARY(1),                      // FN1 - switch to Layer1
 192:keymap.c      ****     ACTION_LAYER_SET(2, ON_PRESS),                  // FN2 - set Layer2
 193:keymap.c      ****     ACTION_LAYER_TOGGLE(3),                         // FN3 - toggle Layer3 aka Numpad layer
 194:keymap.c      ****     ACTION_LAYER_SET(0, ON_PRESS),                  // FN4 - set Layer0
 195:keymap.c      **** };
 196:keymap.c      **** 
 197:keymap.c      **** void action_function(keyrecord_t *event, uint8_t id, uint8_t opt)
 198:keymap.c      **** {
  47               		.loc 2 198 0
  48               		.cfi_startproc
  49               	.LVL0:
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
 199:keymap.c      ****     if (id == TEENSY_KEY) {
  54               		.loc 2 199 0
  55 0000 6111      		cpse r22,__zero_reg__
  56 0002 00C0      		rjmp .L3
 200:keymap.c      ****         clear_keyboard();
  57               		.loc 2 200 0
  58 0004 0E94 0000 		call clear_keyboard
  59               	.LVL1:
 201:keymap.c      ****         print("\n\nJump to bootloader... ");
  60               		.loc 2 201 0
  61 0008 80E0      		ldi r24,lo8(__c.2533)
  62 000a 90E0      		ldi r25,hi8(__c.2533)
  63 000c 0E94 0000 		call xputs
  64               	.LVL2:
  65               	.LBB6:
  66               	.LBB7:
  67               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  68               		.loc 3 163 0
  69 0010 2FEF      		ldi r18,lo8(799999)
  70 0012 84E3      		ldi r24,hi8(799999)
  71 0014 9CE0      		ldi r25,hlo8(799999)
  72 0016 2150      		1: subi r18,1
  73 0018 8040      		sbci r24,0
  74 001a 9040      		sbci r25,0
  75 001c 01F4      		brne 1b
  76 001e 00C0      		rjmp .
  77 0020 0000      		nop
  78               	.LBE7:
  79               	.LBE6:
 202:keymap.c      ****         _delay_ms(250);
 203:keymap.c      ****         bootloader_jump(); // should not return
  80               		.loc 2 203 0
  81 0022 0E94 0000 		call bootloader_jump
  82               	.LVL3:
 204:keymap.c      ****         print("not supported.\n");
  83               		.loc 2 204 0
  84 0026 80E0      		ldi r24,lo8(__c.2535)
  85 0028 90E0      		ldi r25,hi8(__c.2535)
  86 002a 0C94 0000 		jmp xputs
  87               	.LVL4:
  88               	.L3:
  89 002e 0895      		ret
  90               		.cfi_endproc
  91               	.LFE32:
  93               		.section	.text.keymap_key_to_keycode,"ax",@progbits
  94               	.global	keymap_key_to_keycode
  96               	keymap_key_to_keycode:
  97               	.LFB33:
 205:keymap.c      ****     }
 206:keymap.c      **** }
 207:keymap.c      **** 
 208:keymap.c      **** #endif
 209:keymap.c      **** 
 210:keymap.c      **** 
 211:keymap.c      **** #define KEYMAPS_SIZE    (sizeof(keymaps) / sizeof(keymaps[0]))
 212:keymap.c      **** #define FN_ACTIONS_SIZE (sizeof(fn_actions) / sizeof(fn_actions[0]))
 213:keymap.c      **** 
 214:keymap.c      **** /* translates key to keycode */
 215:keymap.c      **** uint8_t keymap_key_to_keycode(uint8_t layer, keypos_t key)
 216:keymap.c      **** {
  98               		.loc 2 216 0
  99               		.cfi_startproc
 100               	.LVL5:
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 0 */
 104               	.L__stack_usage = 0
 105 0000 272F      		mov r18,r23
 106               	.LVL6:
 107 0002 70E0      		ldi r23,0
 108               	.LVL7:
 109 0004 30E0      		ldi r19,0
 217:keymap.c      ****     if (layer < KEYMAPS_SIZE) {
 110               		.loc 2 217 0
 111 0006 8430      		cpi r24,lo8(4)
 112 0008 00F4      		brsh .L7
 113               	.LVL8:
 114               	.LBB8:
 218:keymap.c      ****         return pgm_read_byte(&keymaps[(layer)][(key.row)][(key.col)]);
 115               		.loc 2 218 0
 116 000a 96E0      		ldi r25,lo8(6)
 117 000c 929F      		mul r25,r18
 118 000e F001      		movw r30,r0
 119 0010 939F      		mul r25,r19
 120 0012 F00D      		add r31,r0
 121 0014 1124      		clr __zero_reg__
 122 0016 94E5      		ldi r25,lo8(84)
 123 0018 899F      		mul r24,r25
 124 001a E00D      		add r30,r0
 125 001c F11D      		adc r31,r1
 126 001e 1124      		clr __zero_reg__
 127 0020 00C0      		rjmp .L9
 128               	.LVL9:
 129               	.L7:
 130               	.LBE8:
 131               	.LBB9:
 219:keymap.c      ****     } else {
 220:keymap.c      ****         // fall back to layer 0
 221:keymap.c      ****         return pgm_read_byte(&keymaps[0][(key.row)][(key.col)]);
 132               		.loc 2 221 0
 133 0022 86E0      		ldi r24,lo8(6)
 134               	.LVL10:
 135 0024 829F      		mul r24,r18
 136 0026 F001      		movw r30,r0
 137 0028 839F      		mul r24,r19
 138 002a F00D      		add r31,r0
 139 002c 1124      		clr __zero_reg__
 140               	.LVL11:
 141               	.L9:
 142 002e E60F      		add r30,r22
 143 0030 F71F      		adc r31,r23
 144 0032 E050      		subi r30,lo8(-(keymaps))
 145 0034 F040      		sbci r31,hi8(-(keymaps))
 146               	/* #APP */
 147               	 ;  221 "keymap.c" 1
 148 0036 8491      		lpm r24, Z
 149               		
 150               	 ;  0 "" 2
 151               	.LVL12:
 152               	/* #NOAPP */
 153               	.LBE9:
 222:keymap.c      ****     }
 223:keymap.c      **** }
 154               		.loc 2 223 0
 155 0038 0895      		ret
 156               		.cfi_endproc
 157               	.LFE33:
 159               		.section	.text.keymap_fn_to_action,"ax",@progbits
 160               	.global	keymap_fn_to_action
 162               	keymap_fn_to_action:
 163               	.LFB34:
 224:keymap.c      **** 
 225:keymap.c      **** #if defined(KEYMAP_CUB)
 226:keymap.c      **** 
 227:keymap.c      **** // function keymap_fn_to_action will be defined in keymap_cub.h
 228:keymap.c      **** 
 229:keymap.c      **** #else
 230:keymap.c      **** /* translates Fn keycode to action */
 231:keymap.c      **** action_t keymap_fn_to_action(uint8_t keycode)
 232:keymap.c      **** {
 164               		.loc 2 232 0
 165               		.cfi_startproc
 166               	.LVL13:
 167               	/* prologue: function */
 168               	/* frame size = 0 */
 169               	/* stack size = 0 */
 170               	.L__stack_usage = 0
 233:keymap.c      ****     action_t action;
 234:keymap.c      ****     if (FN_INDEX(keycode) < FN_ACTIONS_SIZE) {
 171               		.loc 2 234 0
 172 0000 E82F      		mov r30,r24
 173 0002 F0E0      		ldi r31,0
 174 0004 E05C      		subi r30,-64
 175 0006 F109      		sbc r31,__zero_reg__
 176 0008 E530      		cpi r30,5
 177 000a F105      		cpc r31,__zero_reg__
 178 000c 00F4      		brsh .L12
 179               	.LBB10:
 235:keymap.c      ****         action.code = pgm_read_word(&fn_actions[FN_INDEX(keycode)]);
 180               		.loc 2 235 0
 181 000e EE0F      		lsl r30
 182 0010 FF1F      		rol r31
 183               	.LVL14:
 184 0012 E050      		subi r30,lo8(-(fn_actions))
 185 0014 F040      		sbci r31,hi8(-(fn_actions))
 186               	.LVL15:
 187               	/* #APP */
 188               	 ;  235 "keymap.c" 1
 189 0016 8591      		lpm r24, Z+
 190 0018 9491      		lpm r25, Z
 191               		
 192               	 ;  0 "" 2
 193               	.LVL16:
 194               	/* #NOAPP */
 195               	.LBE10:
 196 001a 0895      		ret
 197               	.LVL17:
 198               	.L12:
 236:keymap.c      ****     } else {
 237:keymap.c      ****         action.code = ACTION_NO;
 199               		.loc 2 237 0
 200 001c 80E0      		ldi r24,0
 201 001e 90E0      		ldi r25,0
 202               	.LVL18:
 238:keymap.c      ****     }
 239:keymap.c      ****     return action;
 240:keymap.c      **** }
 203               		.loc 2 240 0
 204 0020 0895      		ret
 205               		.cfi_endproc
 206               	.LFE34:
 208               		.section	.progmem.data,"a",@progbits
 211               	__c.2535:
 212 0000 6E6F 7420 		.string	"not supported.\n"
 212      7375 7070 
 212      6F72 7465 
 212      642E 0A00 
 215               	__c.2533:
 216 0010 0A0A 4A75 		.string	"\n\nJump to bootloader... "
 216      6D70 2074 
 216      6F20 626F 
 216      6F74 6C6F 
 216      6164 6572 
 219               	fn_actions:
 220 0029 00F0      		.word	-4096
 221 002b F1A1      		.word	-24079
 222 002d 048D      		.word	-29436
 223 002f 088A      		.word	-30200
 224 0031 018D      		.word	-29439
 227               	keymaps:
 228 0033 29        		.byte	41
 229 0034 2B        		.byte	43
 230 0035 E0        		.byte	-32
 231 0036 E1        		.byte	-31
 232 0037 E3        		.byte	-29
 233 0038 00        		.byte	0
 234 0039 1E        		.byte	30
 235 003a 14        		.byte	20
 236 003b 04        		.byte	4
 237 003c 1D        		.byte	29
 238 003d 35        		.byte	53
 239 003e 4D        		.byte	77
 240 003f 1F        		.byte	31
 241 0040 1A        		.byte	26
 242 0041 16        		.byte	22
 243 0042 1B        		.byte	27
 244 0043 32        		.byte	50
 245 0044 2A        		.byte	42
 246 0045 20        		.byte	32
 247 0046 08        		.byte	8
 248 0047 07        		.byte	7
 249 0048 06        		.byte	6
 250 0049 34        		.byte	52
 251 004a 2C        		.byte	44
 252 004b 21        		.byte	33
 253 004c 15        		.byte	21
 254 004d 09        		.byte	9
 255 004e 19        		.byte	25
 256 004f 31        		.byte	49
 257 0050 4A        		.byte	74
 258 0051 22        		.byte	34
 259 0052 17        		.byte	23
 260 0053 0A        		.byte	10
 261 0054 05        		.byte	5
 262 0055 00        		.byte	0
 263 0056 E0        		.byte	-32
 264 0057 2D        		.byte	45
 265 0058 2F        		.byte	47
 266 0059 00        		.byte	0
 267 005a C1        		.byte	-63
 268 005b 00        		.byte	0
 269 005c E2        		.byte	-30
 270 005d 2E        		.byte	46
 271 005e 30        		.byte	48
 272 005f 00        		.byte	0
 273 0060 C1        		.byte	-63
 274 0061 00        		.byte	0
 275 0062 46        		.byte	70
 276 0063 23        		.byte	35
 277 0064 1C        		.byte	28
 278 0065 0B        		.byte	11
 279 0066 11        		.byte	17
 280 0067 00        		.byte	0
 281 0068 49        		.byte	73
 282 0069 24        		.byte	36
 283 006a 18        		.byte	24
 284 006b 0D        		.byte	13
 285 006c 10        		.byte	16
 286 006d 50        		.byte	80
 287 006e 4B        		.byte	75
 288 006f 25        		.byte	37
 289 0070 0C        		.byte	12
 290 0071 0E        		.byte	14
 291 0072 36        		.byte	54
 292 0073 51        		.byte	81
 293 0074 2C        		.byte	44
 294 0075 26        		.byte	38
 295 0076 12        		.byte	18
 296 0077 0F        		.byte	15
 297 0078 37        		.byte	55
 298 0079 52        		.byte	82
 299 007a 28        		.byte	40
 300 007b 27        		.byte	39
 301 007c 13        		.byte	19
 302 007d 33        		.byte	51
 303 007e 38        		.byte	56
 304 007f 4F        		.byte	79
 305 0080 4E        		.byte	78
 306 0081 4C        		.byte	76
 307 0082 64        		.byte	100
 308 0083 34        		.byte	52
 309 0084 E5        		.byte	-27
 310 0085 E7        		.byte	-25
 311 0086 00        		.byte	0
 312 0087 01        		.byte	1
 313 0088 01        		.byte	1
 314 0089 01        		.byte	1
 315 008a 01        		.byte	1
 316 008b 01        		.byte	1
 317 008c 00        		.byte	0
 318 008d 3A        		.byte	58
 319 008e 01        		.byte	1
 320 008f 01        		.byte	1
 321 0090 01        		.byte	1
 322 0091 01        		.byte	1
 323 0092 01        		.byte	1
 324 0093 3B        		.byte	59
 325 0094 01        		.byte	1
 326 0095 01        		.byte	1
 327 0096 01        		.byte	1
 328 0097 01        		.byte	1
 329 0098 01        		.byte	1
 330 0099 3C        		.byte	60
 331 009a 01        		.byte	1
 332 009b 01        		.byte	1
 333 009c 01        		.byte	1
 334 009d 01        		.byte	1
 335 009e 01        		.byte	1
 336 009f 3D        		.byte	61
 337 00a0 01        		.byte	1
 338 00a1 01        		.byte	1
 339 00a2 01        		.byte	1
 340 00a3 01        		.byte	1
 341 00a4 01        		.byte	1
 342 00a5 3E        		.byte	62
 343 00a6 01        		.byte	1
 344 00a7 01        		.byte	1
 345 00a8 01        		.byte	1
 346 00a9 00        		.byte	0
 347 00aa 01        		.byte	1
 348 00ab 44        		.byte	68
 349 00ac C4        		.byte	-60
 350 00ad 00        		.byte	0
 351 00ae 01        		.byte	1
 352 00af 00        		.byte	0
 353 00b0 01        		.byte	1
 354 00b1 45        		.byte	69
 355 00b2 01        		.byte	1
 356 00b3 00        		.byte	0
 357 00b4 01        		.byte	1
 358 00b5 00        		.byte	0
 359 00b6 01        		.byte	1
 360 00b7 3F        		.byte	63
 361 00b8 01        		.byte	1
 362 00b9 01        		.byte	1
 363 00ba 01        		.byte	1
 364 00bb 00        		.byte	0
 365 00bc 01        		.byte	1
 366 00bd 40        		.byte	64
 367 00be 01        		.byte	1
 368 00bf 01        		.byte	1
 369 00c0 01        		.byte	1
 370 00c1 01        		.byte	1
 371 00c2 01        		.byte	1
 372 00c3 41        		.byte	65
 373 00c4 5F        		.byte	95
 374 00c5 5C        		.byte	92
 375 00c6 59        		.byte	89
 376 00c7 62        		.byte	98
 377 00c8 01        		.byte	1
 378 00c9 42        		.byte	66
 379 00ca 60        		.byte	96
 380 00cb 5D        		.byte	93
 381 00cc 5A        		.byte	90
 382 00cd 62        		.byte	98
 383 00ce 01        		.byte	1
 384 00cf 43        		.byte	67
 385 00d0 61        		.byte	97
 386 00d1 5E        		.byte	94
 387 00d2 5B        		.byte	91
 388 00d3 63        		.byte	99
 389 00d4 01        		.byte	1
 390 00d5 01        		.byte	1
 391 00d6 54        		.byte	84
 392 00d7 55        		.byte	85
 393 00d8 56        		.byte	86
 394 00d9 67        		.byte	103
 395 00da 00        		.byte	0
 396 00db C0        		.byte	-64
 397 00dc 01        		.byte	1
 398 00dd 01        		.byte	1
 399 00de 01        		.byte	1
 400 00df 01        		.byte	1
 401 00e0 00        		.byte	0
 402 00e1 01        		.byte	1
 403 00e2 01        		.byte	1
 404 00e3 01        		.byte	1
 405 00e4 01        		.byte	1
 406 00e5 01        		.byte	1
 407 00e6 01        		.byte	1
 408 00e7 01        		.byte	1
 409 00e8 01        		.byte	1
 410 00e9 01        		.byte	1
 411 00ea 01        		.byte	1
 412 00eb 01        		.byte	1
 413 00ec 01        		.byte	1
 414 00ed 01        		.byte	1
 415 00ee 01        		.byte	1
 416 00ef 01        		.byte	1
 417 00f0 01        		.byte	1
 418 00f1 01        		.byte	1
 419 00f2 01        		.byte	1
 420 00f3 01        		.byte	1
 421 00f4 01        		.byte	1
 422 00f5 01        		.byte	1
 423 00f6 01        		.byte	1
 424 00f7 01        		.byte	1
 425 00f8 01        		.byte	1
 426 00f9 01        		.byte	1
 427 00fa 01        		.byte	1
 428 00fb 01        		.byte	1
 429 00fc 01        		.byte	1
 430 00fd 00        		.byte	0
 431 00fe 01        		.byte	1
 432 00ff 01        		.byte	1
 433 0100 01        		.byte	1
 434 0101 00        		.byte	0
 435 0102 01        		.byte	1
 436 0103 00        		.byte	0
 437 0104 01        		.byte	1
 438 0105 C4        		.byte	-60
 439 0106 01        		.byte	1
 440 0107 00        		.byte	0
 441 0108 01        		.byte	1
 442 0109 00        		.byte	0
 443 010a 01        		.byte	1
 444 010b 01        		.byte	1
 445 010c 01        		.byte	1
 446 010d 01        		.byte	1
 447 010e 01        		.byte	1
 448 010f 00        		.byte	0
 449 0110 01        		.byte	1
 450 0111 01        		.byte	1
 451 0112 01        		.byte	1
 452 0113 01        		.byte	1
 453 0114 01        		.byte	1
 454 0115 01        		.byte	1
 455 0116 01        		.byte	1
 456 0117 01        		.byte	1
 457 0118 01        		.byte	1
 458 0119 01        		.byte	1
 459 011a 01        		.byte	1
 460 011b 01        		.byte	1
 461 011c 01        		.byte	1
 462 011d 01        		.byte	1
 463 011e 01        		.byte	1
 464 011f 01        		.byte	1
 465 0120 01        		.byte	1
 466 0121 01        		.byte	1
 467 0122 01        		.byte	1
 468 0123 01        		.byte	1
 469 0124 01        		.byte	1
 470 0125 01        		.byte	1
 471 0126 01        		.byte	1
 472 0127 01        		.byte	1
 473 0128 01        		.byte	1
 474 0129 01        		.byte	1
 475 012a 01        		.byte	1
 476 012b 01        		.byte	1
 477 012c 01        		.byte	1
 478 012d 01        		.byte	1
 479 012e 00        		.byte	0
 480 012f 01        		.byte	1
 481 0130 01        		.byte	1
 482 0131 01        		.byte	1
 483 0132 01        		.byte	1
 484 0133 01        		.byte	1
 485 0134 00        		.byte	0
 486 0135 01        		.byte	1
 487 0136 01        		.byte	1
 488 0137 01        		.byte	1
 489 0138 01        		.byte	1
 490 0139 01        		.byte	1
 491 013a 01        		.byte	1
 492 013b 01        		.byte	1
 493 013c 01        		.byte	1
 494 013d 01        		.byte	1
 495 013e 01        		.byte	1
 496 013f 01        		.byte	1
 497 0140 01        		.byte	1
 498 0141 01        		.byte	1
 499 0142 01        		.byte	1
 500 0143 01        		.byte	1
 501 0144 01        		.byte	1
 502 0145 01        		.byte	1
 503 0146 01        		.byte	1
 504 0147 01        		.byte	1
 505 0148 01        		.byte	1
 506 0149 01        		.byte	1
 507 014a 01        		.byte	1
 508 014b 01        		.byte	1
 509 014c 01        		.byte	1
 510 014d 01        		.byte	1
 511 014e 01        		.byte	1
 512 014f 01        		.byte	1
 513 0150 01        		.byte	1
 514 0151 00        		.byte	0
 515 0152 01        		.byte	1
 516 0153 01        		.byte	1
 517 0154 01        		.byte	1
 518 0155 00        		.byte	0
 519 0156 01        		.byte	1
 520 0157 00        		.byte	0
 521 0158 01        		.byte	1
 522 0159 01        		.byte	1
 523 015a 01        		.byte	1
 524 015b 00        		.byte	0
 525 015c 01        		.byte	1
 526 015d 00        		.byte	0
 527 015e 01        		.byte	1
 528 015f 53        		.byte	83
 529 0160 00        		.byte	0
 530 0161 00        		.byte	0
 531 0162 00        		.byte	0
 532 0163 00        		.byte	0
 533 0164 01        		.byte	1
 534 0165 54        		.byte	84
 535 0166 5F        		.byte	95
 536 0167 5C        		.byte	92
 537 0168 59        		.byte	89
 538 0169 62        		.byte	98
 539 016a 01        		.byte	1
 540 016b 55        		.byte	85
 541 016c 60        		.byte	96
 542 016d 5D        		.byte	93
 543 016e 5A        		.byte	90
 544 016f 63        		.byte	99
 545 0170 01        		.byte	1
 546 0171 55        		.byte	85
 547 0172 61        		.byte	97
 548 0173 5E        		.byte	94
 549 0174 5B        		.byte	91
 550 0175 38        		.byte	56
 551 0176 01        		.byte	1
 552 0177 56        		.byte	86
 553 0178 56        		.byte	86
 554 0179 57        		.byte	87
 555 017a 57        		.byte	87
 556 017b 58        		.byte	88
 557 017c 01        		.byte	1
 558 017d 2A        		.byte	42
 559 017e 2A        		.byte	42
 560 017f 58        		.byte	88
 561 0180 58        		.byte	88
 562 0181 58        		.byte	88
 563 0182 00        		.byte	0
 564               		.comm	keymap_config,1,1
 565               		.text
 566               	.Letext0:
 567               		.file 4 "/usr/lib/avr/include/stdint.h"
 568               		.file 5 "../../common/keycode.h"
 569               		.file 6 "../../common/action_code.h"
 570               		.file 7 "../../common/action.h"
 571               		.file 8 "../../common/keymap.h"
 572               		.file 9 "ergodox.h"
 573               		.file 10 "../../common/bootloader.h"
 574               		.file 11 "../../common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 keymap.c
     /tmp/ccy22G5S.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccy22G5S.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccy22G5S.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccy22G5S.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccy22G5S.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccy22G5S.s:13     .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccy22G5S.s:29     .text.matrix_power_down:0000000000000000 matrix_power_down
     /tmp/ccy22G5S.s:44     .text.action_function:0000000000000000 action_function
     /tmp/ccy22G5S.s:215    .progmem.data:0000000000000010 __c.2533
     /tmp/ccy22G5S.s:211    .progmem.data:0000000000000000 __c.2535
     /tmp/ccy22G5S.s:96     .text.keymap_key_to_keycode:0000000000000000 keymap_key_to_keycode
     /tmp/ccy22G5S.s:227    .progmem.data:0000000000000033 keymaps
     /tmp/ccy22G5S.s:162    .text.keymap_fn_to_action:0000000000000000 keymap_fn_to_action
     /tmp/ccy22G5S.s:219    .progmem.data:0000000000000029 fn_actions
                            *COM*:0000000000000001 keymap_config

UNDEFINED SYMBOLS
clear_keyboard
xputs
bootloader_jump
__do_clear_bss
