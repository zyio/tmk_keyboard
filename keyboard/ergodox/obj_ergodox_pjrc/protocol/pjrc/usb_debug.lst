   1               		.file	"usb_debug.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sendchar,"ax",@progbits
  11               	.global	sendchar
  13               	sendchar:
  14               	.LFB0:
  15               		.file 1 "../../protocol/pjrc/usb_debug.c"
   1:../../protocol/pjrc/usb_debug.c **** /* USB Keyboard Plus Debug Channel Example for Teensy USB Development Board
   2:../../protocol/pjrc/usb_debug.c ****  * http://www.pjrc.com/teensy/usb_keyboard.html
   3:../../protocol/pjrc/usb_debug.c ****  * Copyright (c) 2009 PJRC.COM, LLC
   4:../../protocol/pjrc/usb_debug.c ****  *
   5:../../protocol/pjrc/usb_debug.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:../../protocol/pjrc/usb_debug.c ****  * of this software and associated documentation files (the "Software"), to deal
   7:../../protocol/pjrc/usb_debug.c ****  * in the Software without restriction, including without limitation the rights
   8:../../protocol/pjrc/usb_debug.c ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:../../protocol/pjrc/usb_debug.c ****  * copies of the Software, and to permit persons to whom the Software is
  10:../../protocol/pjrc/usb_debug.c ****  * furnished to do so, subject to the following conditions:
  11:../../protocol/pjrc/usb_debug.c ****  *
  12:../../protocol/pjrc/usb_debug.c ****  * The above copyright notice and this permission notice shall be included in
  13:../../protocol/pjrc/usb_debug.c ****  * all copies or substantial portions of the Software.
  14:../../protocol/pjrc/usb_debug.c ****  *
  15:../../protocol/pjrc/usb_debug.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../../protocol/pjrc/usb_debug.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:../../protocol/pjrc/usb_debug.c ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:../../protocol/pjrc/usb_debug.c ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:../../protocol/pjrc/usb_debug.c ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:../../protocol/pjrc/usb_debug.c ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:../../protocol/pjrc/usb_debug.c ****  * THE SOFTWARE.
  22:../../protocol/pjrc/usb_debug.c ****  */
  23:../../protocol/pjrc/usb_debug.c **** 
  24:../../protocol/pjrc/usb_debug.c **** #include <avr/interrupt.h>
  25:../../protocol/pjrc/usb_debug.c **** #include "sendchar.h"
  26:../../protocol/pjrc/usb_debug.c **** #include "usb_debug.h"
  27:../../protocol/pjrc/usb_debug.c **** 
  28:../../protocol/pjrc/usb_debug.c **** 
  29:../../protocol/pjrc/usb_debug.c **** // the time remaining before we transmit any partially full
  30:../../protocol/pjrc/usb_debug.c **** // packet, or send a zero length packet.
  31:../../protocol/pjrc/usb_debug.c **** volatile uint8_t debug_flush_timer=0;
  32:../../protocol/pjrc/usb_debug.c **** 
  33:../../protocol/pjrc/usb_debug.c **** 
  34:../../protocol/pjrc/usb_debug.c **** int8_t sendchar(uint8_t c)
  35:../../protocol/pjrc/usb_debug.c **** {
  16               		.loc 1 35 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 1F93      		push r17
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 17, -2
  23 0002 CF93      		push r28
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 28, -3
  27 0004 DF93      		push r29
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 29, -4
  31               	/* prologue: function */
  32               	/* frame size = 0 */
  33               	/* stack size = 3 */
  34               	.L__stack_usage = 3
  35 0006 D82F      		mov r29,r24
  36:../../protocol/pjrc/usb_debug.c **** 	static uint8_t previous_timeout=0;
  37:../../protocol/pjrc/usb_debug.c **** 	uint8_t timeout, intr_state;
  38:../../protocol/pjrc/usb_debug.c **** 
  39:../../protocol/pjrc/usb_debug.c **** 	// if we're not online (enumerated and configured), error
  40:../../protocol/pjrc/usb_debug.c **** 	if (!usb_configured()) return -1;
  36               		.loc 1 40 0
  37 0008 0E94 0000 		call usb_configured
  38               	.LVL1:
  39 000c 8823      		tst r24
  40 000e 01F0      		breq .L18
  41:../../protocol/pjrc/usb_debug.c **** 	// interrupts are disabled so these functions can be
  42:../../protocol/pjrc/usb_debug.c **** 	// used from the main program or interrupt context,
  43:../../protocol/pjrc/usb_debug.c **** 	// even both in the same program!
  44:../../protocol/pjrc/usb_debug.c **** 	intr_state = SREG;
  41               		.loc 1 44 0
  42 0010 9FB7      		in r25,__SREG__
  43               	.LVL2:
  45:../../protocol/pjrc/usb_debug.c **** 	cli();
  44               		.loc 1 45 0
  45               	/* #APP */
  46               	 ;  45 "../../protocol/pjrc/usb_debug.c" 1
  47 0012 F894      		cli
  48               	 ;  0 "" 2
  46:../../protocol/pjrc/usb_debug.c **** 	UENUM = DEBUG_TX_ENDPOINT;
  49               		.loc 1 46 0
  50               	/* #NOAPP */
  51 0014 83E0      		ldi r24,lo8(3)
  52 0016 8093 E900 		sts 233,r24
  47:../../protocol/pjrc/usb_debug.c **** 	// if we gave up due to timeout before, don't wait again
  48:../../protocol/pjrc/usb_debug.c **** 	if (previous_timeout) {
  53               		.loc 1 48 0
  54 001a 8091 0000 		lds r24,previous_timeout.1512
  55 001e 8823      		tst r24
  56 0020 01F0      		breq .L4
  49:../../protocol/pjrc/usb_debug.c **** 		if (!(UEINTX & (1<<RWAL))) {
  57               		.loc 1 49 0
  58 0022 8091 E800 		lds r24,232
  59 0026 85FD      		sbrc r24,5
  60 0028 00C0      		rjmp .L5
  50:../../protocol/pjrc/usb_debug.c **** 			SREG = intr_state;
  61               		.loc 1 50 0
  62 002a 9FBF      		out __SREG__,r25
  63               	.LVL3:
  64               	.L18:
  51:../../protocol/pjrc/usb_debug.c **** 			return -1;
  65               		.loc 1 51 0
  66 002c 8FEF      		ldi r24,lo8(-1)
  67 002e 00C0      		rjmp .L3
  68               	.LVL4:
  69               	.L5:
  52:../../protocol/pjrc/usb_debug.c **** 		}
  53:../../protocol/pjrc/usb_debug.c **** 		previous_timeout = 0;
  70               		.loc 1 53 0
  71 0030 1092 0000 		sts previous_timeout.1512,__zero_reg__
  72               	.L4:
  54:../../protocol/pjrc/usb_debug.c **** 	}
  55:../../protocol/pjrc/usb_debug.c **** 	// wait for the FIFO to be ready to accept data
  56:../../protocol/pjrc/usb_debug.c **** 	timeout = UDFNUML + 4;
  73               		.loc 1 56 0
  74 0034 C091 E400 		lds r28,228
  75 0038 CC5F      		subi r28,lo8(-(4))
  76               	.LVL5:
  57:../../protocol/pjrc/usb_debug.c **** 	while (1) {
  58:../../protocol/pjrc/usb_debug.c **** 		// are we ready to transmit?
  59:../../protocol/pjrc/usb_debug.c **** 		if (UEINTX & (1<<RWAL)) break;
  60:../../protocol/pjrc/usb_debug.c **** 		SREG = intr_state;
  61:../../protocol/pjrc/usb_debug.c **** 		// have we waited too long?
  62:../../protocol/pjrc/usb_debug.c **** 		if (UDFNUML == timeout) {
  63:../../protocol/pjrc/usb_debug.c **** 			previous_timeout = 1;
  64:../../protocol/pjrc/usb_debug.c **** 			return -1;
  65:../../protocol/pjrc/usb_debug.c **** 		}
  66:../../protocol/pjrc/usb_debug.c **** 		// has the USB gone offline?
  67:../../protocol/pjrc/usb_debug.c **** 		if (!usb_configured()) return -1;
  68:../../protocol/pjrc/usb_debug.c **** 		// get ready to try checking again
  69:../../protocol/pjrc/usb_debug.c **** 		intr_state = SREG;
  70:../../protocol/pjrc/usb_debug.c **** 		cli();
  71:../../protocol/pjrc/usb_debug.c **** 		UENUM = DEBUG_TX_ENDPOINT;
  77               		.loc 1 71 0
  78 003a 13E0      		ldi r17,lo8(3)
  79               	.L9:
  59:../../protocol/pjrc/usb_debug.c **** 		SREG = intr_state;
  80               		.loc 1 59 0
  81 003c 8091 E800 		lds r24,232
  82 0040 85FD      		sbrc r24,5
  83 0042 00C0      		rjmp .L6
  60:../../protocol/pjrc/usb_debug.c **** 		// have we waited too long?
  84               		.loc 1 60 0
  85 0044 9FBF      		out __SREG__,r25
  62:../../protocol/pjrc/usb_debug.c **** 			previous_timeout = 1;
  86               		.loc 1 62 0
  87 0046 8091 E400 		lds r24,228
  88 004a 8C13      		cpse r24,r28
  89 004c 00C0      		rjmp .L7
  63:../../protocol/pjrc/usb_debug.c **** 			return -1;
  90               		.loc 1 63 0
  91 004e 81E0      		ldi r24,lo8(1)
  92 0050 8093 0000 		sts previous_timeout.1512,r24
  93 0054 00C0      		rjmp .L18
  94               	.L7:
  67:../../protocol/pjrc/usb_debug.c **** 		// get ready to try checking again
  95               		.loc 1 67 0
  96 0056 0E94 0000 		call usb_configured
  97               	.LVL6:
  98 005a 8823      		tst r24
  99 005c 01F0      		breq .L18
  69:../../protocol/pjrc/usb_debug.c **** 		cli();
 100               		.loc 1 69 0
 101 005e 9FB7      		in r25,__SREG__
 102               	.LVL7:
  70:../../protocol/pjrc/usb_debug.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 103               		.loc 1 70 0
 104               	/* #APP */
 105               	 ;  70 "../../protocol/pjrc/usb_debug.c" 1
 106 0060 F894      		cli
 107               	 ;  0 "" 2
 108               		.loc 1 71 0
 109               	/* #NOAPP */
 110 0062 1093 E900 		sts 233,r17
  72:../../protocol/pjrc/usb_debug.c **** 	}
 111               		.loc 1 72 0
 112 0066 00C0      		rjmp .L9
 113               	.L6:
  73:../../protocol/pjrc/usb_debug.c **** 	// actually write the byte into the FIFO
  74:../../protocol/pjrc/usb_debug.c **** 	UEDATX = c;
 114               		.loc 1 74 0
 115 0068 D093 F100 		sts 241,r29
  75:../../protocol/pjrc/usb_debug.c **** 	// if this completed a packet, transmit it now!
  76:../../protocol/pjrc/usb_debug.c **** 	if (!(UEINTX & (1<<RWAL))) {
 116               		.loc 1 76 0
 117 006c 8091 E800 		lds r24,232
 118 0070 85FD      		sbrc r24,5
 119 0072 00C0      		rjmp .L10
  77:../../protocol/pjrc/usb_debug.c **** 		UEINTX = 0x3A;
 120               		.loc 1 77 0
 121 0074 8AE3      		ldi r24,lo8(58)
 122 0076 8093 E800 		sts 232,r24
  78:../../protocol/pjrc/usb_debug.c **** 		debug_flush_timer = 0;
 123               		.loc 1 78 0
 124 007a 1092 0000 		sts debug_flush_timer,__zero_reg__
 125 007e 00C0      		rjmp .L11
 126               	.L10:
  79:../../protocol/pjrc/usb_debug.c **** 	} else {
  80:../../protocol/pjrc/usb_debug.c **** 		debug_flush_timer = 2;
 127               		.loc 1 80 0
 128 0080 82E0      		ldi r24,lo8(2)
 129 0082 8093 0000 		sts debug_flush_timer,r24
 130               	.L11:
  81:../../protocol/pjrc/usb_debug.c **** 	}
  82:../../protocol/pjrc/usb_debug.c **** 	SREG = intr_state;
 131               		.loc 1 82 0
 132 0086 9FBF      		out __SREG__,r25
  83:../../protocol/pjrc/usb_debug.c **** 	return 0;
 133               		.loc 1 83 0
 134 0088 80E0      		ldi r24,0
 135               	.LVL8:
 136               	.L3:
 137               	/* epilogue start */
  84:../../protocol/pjrc/usb_debug.c **** }
 138               		.loc 1 84 0
 139 008a DF91      		pop r29
 140               	.LVL9:
 141 008c CF91      		pop r28
 142 008e 1F91      		pop r17
 143 0090 0895      		ret
 144               		.cfi_endproc
 145               	.LFE0:
 147               		.section	.text.usb_debug_flush_output,"ax",@progbits
 148               	.global	usb_debug_flush_output
 150               	usb_debug_flush_output:
 151               	.LFB1:
  85:../../protocol/pjrc/usb_debug.c **** 
  86:../../protocol/pjrc/usb_debug.c **** // immediately transmit any buffered output.
  87:../../protocol/pjrc/usb_debug.c **** void usb_debug_flush_output(void)
  88:../../protocol/pjrc/usb_debug.c **** {
 152               		.loc 1 88 0
 153               		.cfi_startproc
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 0 */
 157               	.L__stack_usage = 0
  89:../../protocol/pjrc/usb_debug.c **** 	uint8_t intr_state;
  90:../../protocol/pjrc/usb_debug.c **** 
  91:../../protocol/pjrc/usb_debug.c **** 	intr_state = SREG;
 158               		.loc 1 91 0
 159 0000 8FB7      		in r24,__SREG__
 160               	.LVL10:
  92:../../protocol/pjrc/usb_debug.c **** 	cli();
 161               		.loc 1 92 0
 162               	/* #APP */
 163               	 ;  92 "../../protocol/pjrc/usb_debug.c" 1
 164 0002 F894      		cli
 165               	 ;  0 "" 2
  93:../../protocol/pjrc/usb_debug.c **** 	if (debug_flush_timer) {
 166               		.loc 1 93 0
 167               	/* #NOAPP */
 168 0004 9091 0000 		lds r25,debug_flush_timer
 169 0008 9923      		tst r25
 170 000a 01F0      		breq .L21
  94:../../protocol/pjrc/usb_debug.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 171               		.loc 1 94 0
 172 000c 93E0      		ldi r25,lo8(3)
 173 000e 9093 E900 		sts 233,r25
 174               	.L22:
  95:../../protocol/pjrc/usb_debug.c **** 		while ((UEINTX & (1<<RWAL))) {
 175               		.loc 1 95 0 discriminator 1
 176 0012 9091 E800 		lds r25,232
 177 0016 95FF      		sbrs r25,5
 178 0018 00C0      		rjmp .L27
  96:../../protocol/pjrc/usb_debug.c **** 			UEDATX = 0;
 179               		.loc 1 96 0
 180 001a 1092 F100 		sts 241,__zero_reg__
 181 001e 00C0      		rjmp .L22
 182               	.L27:
  97:../../protocol/pjrc/usb_debug.c **** 		}
  98:../../protocol/pjrc/usb_debug.c **** 		UEINTX = 0x3A;
 183               		.loc 1 98 0
 184 0020 9AE3      		ldi r25,lo8(58)
 185 0022 9093 E800 		sts 232,r25
  99:../../protocol/pjrc/usb_debug.c **** 		debug_flush_timer = 0;
 186               		.loc 1 99 0
 187 0026 1092 0000 		sts debug_flush_timer,__zero_reg__
 188               	.L21:
 100:../../protocol/pjrc/usb_debug.c **** 	}
 101:../../protocol/pjrc/usb_debug.c **** 	SREG = intr_state;
 189               		.loc 1 101 0
 190 002a 8FBF      		out __SREG__,r24
 191 002c 0895      		ret
 192               		.cfi_endproc
 193               	.LFE1:
 195               		.local	previous_timeout.1512
 196               		.comm	previous_timeout.1512,1,1
 197               	.global	debug_flush_timer
 198               		.section .bss
 201               	debug_flush_timer:
 202 0000 00        		.zero	1
 203               		.text
 204               	.Letext0:
 205               		.file 2 "/usr/lib/avr/include/stdint.h"
 206               		.file 3 "../../protocol/pjrc/usb.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_debug.c
     /tmp/ccbM75O3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccbM75O3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccbM75O3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccbM75O3.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccbM75O3.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccbM75O3.s:13     .text.sendchar:0000000000000000 sendchar
                             .bss:0000000000000001 previous_timeout.1512
     /tmp/ccbM75O3.s:201    .bss:0000000000000000 debug_flush_timer
     /tmp/ccbM75O3.s:150    .text.usb_debug_flush_output:0000000000000000 usb_debug_flush_output

UNDEFINED SYMBOLS
usb_configured
__do_clear_bss
